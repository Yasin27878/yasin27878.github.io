<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>HashMap的实现原理 | We&#39;re here to put a dent in the universe | 爱生活，爱编程</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#212121">
    
    
    <meta name="keywords" content="Java,Hashmap">
    <meta name="description" content="HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。">
<meta name="keywords" content="Java,Hashmap">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap的实现原理">
<meta property="og:url" content="https://www.jianshu.com/u/3e759a2c717f/2017/09/10/HashMap的实现原理/index.html">
<meta property="og:site_name" content="We&#39;re here to put a dent in the universe">
<meta property="og:description" content="HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://pic002.cnblogs.com/images/2012/80896/2012060316385671.jpg">
<meta property="og:updated_time" content="2019-01-24T09:40:27.917Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HashMap的实现原理">
<meta name="twitter:description" content="HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。">
<meta name="twitter:image" content="http://pic002.cnblogs.com/images/2012/80896/2012060316385671.jpg">
    
        <link rel="alternate" type="application/atom+xml" title="We&#39;re here to put a dent in the universe" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.png">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avater.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Yaisn Yao</h5>
          <a href="mailto:Yasin27878@163.com" title="Yasin27878@163.com" class="mail">Yasin27878@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/">
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives">
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags">
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories">
                <i class="icon icon-lg icon-th-list"></i>
                类别
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Yasin27878" target="_blank">
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://www.weibo.com/ysweb" target="_blank">
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/custom">
                <i class="icon icon-lg icon-link"></i>
                其他
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">HashMap的实现原理</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">HashMap的实现原理</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-09-10T08:07:36.000Z" itemprop="datePublished" class="page-time">
  2017-09-10
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java/">Java</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#HashMap的实现原理"><span class="post-toc-number">1.</span> <span class="post-toc-text">HashMap的实现原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-HashMap概述"><span class="post-toc-number">1.0.0.1.</span> <span class="post-toc-text">1.HashMap概述</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-HashMap的数据结构"><span class="post-toc-number">1.0.0.2.</span> <span class="post-toc-text">2.HashMap的数据结构</span></a></li></ol></li></ol><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">　　</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-HashMap的初始化过程"><span class="post-toc-number">1.1.0.1.</span> <span class="post-toc-text">3. HashMap的初始化过程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#this-var1-var2-实际调用的构造方法"><span class="post-toc-number">1.1.0.1.1.</span> <span class="post-toc-text">this(var1,var2)实际调用的构造方法</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#inflateTable方法"><span class="post-toc-number">1.1.0.1.2.</span> <span class="post-toc-text">inflateTable方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#这里面有个重点"><span class="post-toc-number">1.1.0.1.2.1.</span> <span class="post-toc-text">这里面有个重点</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#那么问题来了-为啥内部数组大小为啥是2-n呢"><span class="post-toc-number">1.1.0.1.3.</span> <span class="post-toc-text">那么问题来了  为啥内部数组大小为啥是2^n呢?</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#putAllForCreate方法"><span class="post-toc-number">1.1.0.1.4.</span> <span class="post-toc-text">putAllForCreate方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#1-计算key的hash值"><span class="post-toc-number">1.1.0.1.4.1.</span> <span class="post-toc-text">1.计算key的hash值</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#2-计算数组下标-根据hash值求余-即余数相同的hash值放到相同的数组下标对应的一个链表上-按位取并，作用上相当于取模mod或者取余-。这意味着数组下标相同，并不表示hashCode相同。"><span class="post-toc-number">1.1.0.1.4.2.</span> <span class="post-toc-text">2.计算数组下标(根据hash值求余,即余数相同的hash值放到相同的数组下标对应的一个链表上)按位取并，作用上相当于取模mod或者取余%。这意味着数组下标相同，并不表示hashCode相同。</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#3-在对应的key上赋值或者添加一组map"><span class="post-toc-number">1.1.0.1.4.3.</span> <span class="post-toc-text">3.在对应的key上赋值或者添加一组map</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-HashMap的存取实现"><span class="post-toc-number">1.1.0.2.</span> <span class="post-toc-text">4.HashMap的存取实现</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#存储数据"><span class="post-toc-number">1.1.0.2.1.</span> <span class="post-toc-text">存储数据</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#读取数据"><span class="post-toc-number">1.1.0.3.</span> <span class="post-toc-text">读取数据</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-HashMap的扩容"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">5.HashMap的扩容</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-Fail-Fast机制："><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">6.Fail-Fast机制：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#解决办法"><span class="post-toc-number">1.1.2.1.</span> <span class="post-toc-text">解决办法</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#参考资料"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">参考资料</span></a></li>
        </nav>
    </aside>


<article id="post-HashMap的实现原理" class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">HashMap的实现原理</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-09-10 16:07:36" datetime="2017-09-10T08:07:36.000Z" itemprop="datePublished">2017-09-10</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java/">Java</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style="display:none">
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br><a id="more"></a></p>
<h1 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h1><h4 id="1-HashMap概述"><a href="#1-HashMap概述" class="headerlink" title="1.HashMap概述"></a>1.HashMap概述</h4><p>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<hr>
<h4 id="2-HashMap的数据结构"><a href="#2-HashMap的数据结构" class="headerlink" title="2.HashMap的数据结构"></a>2.HashMap的数据结构</h4><p>在 Java 编程语言中，最基本的结构就是两种，一个是数组，另外一个是指针（引用），HashMap 就是通过这两个数据结构进行实现。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。<br><img src="http://pic002.cnblogs.com/images/2012/80896/2012060316385671.jpg" alt="image"></p>
<p>每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢? 一般情况是通过hash(key)%len获得，也就是元素的key的哈希值对数组长度取模得到。比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。</p>
<p>　　HashMap其实也是一个线性的数组实现的,所以可以理解为其存储数据的容器就是一个线性数组。这可能让我们很不解，一个线性的数组怎么实现按键值对来存取数据呢？这里HashMap有做一些处理。</p>
<p>　　首先HashMap里面实现一个静态内部类Entry，其重要的属性有 key , value, next，从属性key,value我们就能很明显的看出来Entry就是HashMap键值对实现的一个基础bean，我们上面说到HashMap的基础就是一个线性数组，这个数组就是Entry[]，Map里面的内容都保存在Entry[]里面。</p>
<h2 id=""><a href="#" class="headerlink" title="　　"></a>　　</h2><h4 id="3-HashMap的初始化过程"><a href="#3-HashMap的初始化过程" class="headerlink" title="3. HashMap的初始化过程"></a>3. HashMap的初始化过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　    public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">    this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1,</span><br><span class="line">                  DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">    inflateTable(threshold);</span><br><span class="line"></span><br><span class="line">    putAllForCreate(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>DEFAULT_LOAD_FACTOR :</strong>  负载因子的默认值0.75  表示数据填充的临界值,即数据达到总数据的75%时就开始准备扩容了.</p>
<p><strong>DEFAULT_INITIAL_CAPACITY :</strong> 默认传入Map中的数据默认值为4<br>从上面看出 现实调用自己的构造方法,然后创建存储的Table(实际是数组),最后把值添加到创建的table中</p>
<ul>
<li><h5 id="this-var1-var2-实际调用的构造方法"><a href="#this-var1-var2-实际调用的构造方法" class="headerlink" title="this(var1,var2)实际调用的构造方法"></a>this(var1,var2)实际调用的构造方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span><br><span class="line"> * capacity and load factor.</span><br><span class="line"> *</span><br><span class="line"> * @param  initialCapacity the initial capacity</span><br><span class="line"> * @param  loadFactor      the load factor</span><br><span class="line"> * @throws IllegalArgumentException if the initial capacity is negative</span><br><span class="line"> *         or the load factor is nonpositive</span><br><span class="line"> */</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    &#125; else if (initialCapacity &lt; DEFAULT_INITIAL_CAPACITY) &#123;</span><br><span class="line">        initialCapacity = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>initialCapacity :</strong> ==即初始化申请空间的值,不等于Map实际初始化的内部数组的长度(稍后解释为什么)==,若不填写默认是DEFAULT_INITIAL_CAPACITY也就是4<br>initialCapacity的最大值为1 &lt;&lt; 30 也就是2^30次方<br>initialCapacity的最小值为DEFAULT_INITIAL_CAPACITY也就是4</p>
<p><strong>loadFactor :</strong> 负载因子的初始化值,若不填写默认为DEFAULT_LOAD_FACTOR也就是0.75</p>
<p><strong>threshold :</strong> 下次扩容时的申请空间值</p>
<ul>
<li><h5 id="inflateTable方法"><a href="#inflateTable方法" class="headerlink" title="inflateTable方法"></a>inflateTable方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Inflates the table.</span><br><span class="line"> */</span><br><span class="line">private void inflateTable(int toSize) &#123;</span><br><span class="line">    // Find a power of 2 &gt;= toSize</span><br><span class="line">    int capacity = roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">    // Android-changed: Replace usage of Math.min() here because this method is</span><br><span class="line">    // called from the &lt;clinit&gt; of runtime, at which point the native libraries</span><br><span class="line">    // needed by Float.* might not be loaded.</span><br><span class="line">    float thresholdFloat = capacity * loadFactor;</span><br><span class="line">    if (thresholdFloat &gt; MAXIMUM_CAPACITY + 1) &#123;</span><br><span class="line">        thresholdFloat = MAXIMUM_CAPACITY + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threshold = (int) thresholdFloat;</span><br><span class="line">    table = new HashMapEntry[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="这里面有个重点"><a href="#这里面有个重点" class="headerlink" title="这里面有个重点"></a>这里面有个重点</h6><p> 实际申请的内部数组的大小 int capacity = roundUpToPowerOf2(toSize);</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    private static int roundUpToPowerOf2(int number) &#123;</span><br><span class="line">    // assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span><br><span class="line">    int rounded = number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">            ? MAXIMUM_CAPACITY</span><br><span class="line">            : (rounded = Integer.highestOneBit(number)) != 0</span><br><span class="line">                ? (Integer.bitCount(number) &gt; 1) ? rounded &lt;&lt; 1 : rounded</span><br><span class="line">                : 1;</span><br><span class="line"></span><br><span class="line">    return rounded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这段代码在传入的number在正常数值都会走 Integer.highestOneBit(number)和Integer.bitCount(number)<br>    里面的代码都是位运算 ==roundUpToPowerOf2这个方法实际上的功能就是返回一个最小的是2^n且它大于等于number的值==</p>
<p> 例如 number= 4 那么roundUpToPowerOf2的返回值就是2^2 = 4</p>
<p> number = 5 那么roundUpToPowerOf2的返回值就是2^3 = 8</p>
<h5 id="那么问题来了-为啥内部数组大小为啥是2-n呢"><a href="#那么问题来了-为啥内部数组大小为啥是2-n呢" class="headerlink" title="那么问题来了  为啥内部数组大小为啥是2^n呢?"></a>那么问题来了  为啥内部数组大小为啥是2^n呢?</h5><p>而当数组长度为16时，即为2的n次方时，2n-1得到的二进制数的每个位上的值都为1（比如(24-1)2=1111），这使得在低位上&amp;时，得到的和原hash的低位相同，加之hash(int h)方法对key的hashCode的进一步优化，加入了高位计算，就使得只有相同的hash值的两个值才会被放到数组中的同一个位置上形成链表。</p>
<p>　所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p>
<ul>
<li><h5 id="putAllForCreate方法"><a href="#putAllForCreate方法" class="headerlink" title="putAllForCreate方法"></a>putAllForCreate方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void putAllForCreate(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">    for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">        putForCreate(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里是个foreach循环,将m中的数据拿出来一一添加到map, 下面看具体的putForCreate方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * This method is used instead of put by constructors and</span><br><span class="line"> * pseudoconstructors (clone, readObject).  It does not resize the table,</span><br><span class="line"> * check for comodification, etc.  It calls createEntry rather than</span><br><span class="line"> * addEntry.</span><br><span class="line"> */</span><br><span class="line">private void putForCreate(K key, V value) &#123;</span><br><span class="line">    int hash = null == key ? 0 : sun.misc.Hashing.singleWordWangJenkinsHash(key);</span><br><span class="line">    int i = indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Look for preexisting entry for key.  This will never happen for</span><br><span class="line">     * clone or deserialize.  It will only happen for construction if the</span><br><span class="line">     * input Map is a sorted map whose ordering is inconsistent w/ equals.</span><br><span class="line">     */</span><br><span class="line">    for (HashMapEntry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="1-计算key的hash值"><a href="#1-计算key的hash值" class="headerlink" title="1.计算key的hash值"></a>1.计算key的hash值</h6><p>key==null  -&gt;   hash=0 </p>
<p>key!=null -&gt; hash = hash(key)</p>
<h6 id="2-计算数组下标-根据hash值求余-即余数相同的hash值放到相同的数组下标对应的一个链表上-按位取并，作用上相当于取模mod或者取余-。这意味着数组下标相同，并不表示hashCode相同。"><a href="#2-计算数组下标-根据hash值求余-即余数相同的hash值放到相同的数组下标对应的一个链表上-按位取并，作用上相当于取模mod或者取余-。这意味着数组下标相同，并不表示hashCode相同。" class="headerlink" title="2.计算数组下标(根据hash值求余,即余数相同的hash值放到相同的数组下标对应的一个链表上)按位取并，作用上相当于取模mod或者取余%。这意味着数组下标相同，并不表示hashCode相同。"></a>2.计算数组下标(根据hash值求余,即余数相同的hash值放到相同的数组下标对应的一个链表上)按位取并，作用上相当于取模mod或者取余%。这意味着数组下标相同，并不表示hashCode相同。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns index for hash code h.</span><br><span class="line"> */</span><br><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="3-在对应的key上赋值或者添加一组map"><a href="#3-在对应的key上赋值或者添加一组map" class="headerlink" title="3.在对应的key上赋值或者添加一组map"></a>3.在对应的key上赋值或者添加一组map</h6><hr>
<h4 id="4-HashMap的存取实现"><a href="#4-HashMap的存取实现" class="headerlink" title="4.HashMap的存取实现"></a>4.HashMap的存取实现</h4><p>HashMap的基本存取过程基本如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 存储时:</span><br><span class="line">int hash = key.hashCode(); // 这个hashCode方法这里不详述,只要理解每个key的hash是一个固定的int值</span><br><span class="line">int index = hash % Entry[].length;</span><br><span class="line">Entry[index] = value;</span><br><span class="line"></span><br><span class="line">// 取值时:</span><br><span class="line">int hash = key.hashCode();</span><br><span class="line">int index = hash % Entry[].length;</span><br><span class="line">return Entry[index];</span><br></pre></td></tr></table></figure></p>
<ul>
<li><h5 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    if (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    if (key == null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">    int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key);</span><br><span class="line">    int i = indexFor(hash, table.length);</span><br><span class="line">    for (HashMapEntry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>从上面的源代码中可以看出：<br>1.Map支持key=null<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private V putForNullKey(V value) &#123;</span><br><span class="line">    for (HashMapEntry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;</span><br><span class="line">        if (e.key == null) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(0, null, value, 0);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码中可以看到当key==null 会将值放到table[0]索引下,并且当数据重复时,新数据会覆盖原数据,并返回原数据,若不重复则添加到table hash=0,bucketIndex=0;</p>
<p>2.当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</p>
<p>addEntry方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    // 获取指定 bucketIndex 索引处的 Entry </span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    // 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry</span><br><span class="line">    table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); //参数e, 是Entry.next</span><br><span class="line">    // 如果 Map 中的 key-value 对的数量超过了极限</span><br><span class="line">    if (size++ &gt;= threshold)</span><br><span class="line">    // 把 table 对象的长度扩充到原来的2倍。</span><br><span class="line">            resize(2 * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>储HashMap中的key-value对时，完全没有考虑Entry中的value，仅仅只是根据key来计算并决定每个Entry的存储位置。我们完全可以把 Map 集合中的 value 当成 key 的附属，当系统决定了 key 的存储位置之后，value 随之保存在那里即可。</p>
<p>　　hash(int h)方法根据key的hashCode重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的hash冲突。</p>
<p>   当然HashMap里面也包含一些优化方面的实现，这里也说一下。比如：Entry[]的长度一定后，随着map里面数据的越来越长，这样同一个index的链就会很长，会不会影响性能？HashMap里面设置一个因子(loadFactor)，随着map的size越来越大，Entry[]会以一定的规则加长长度。</p>
<ul>
<li><h4 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   public V get(Object key) &#123;</span><br><span class="line">    if (key == null)</span><br><span class="line">        return getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    return null == entry ? null : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当key=null 直接取table的索引为0下的值;<br>当key!=null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">    if (size == 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int hash = (key == null) ? 0 : sun.misc.Hashing.singleWordWangJenkinsHash(key);</span><br><span class="line">    for (HashMapEntry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != null;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return e;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从HashMap中get元素时，首先计算key的hashCode，在通过indexFor方法找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。</p>
<p>归纳起来简单地说，HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。</p>
</li>
</ul>
<hr>
<h3 id="5-HashMap的扩容"><a href="#5-HashMap的扩容" class="headerlink" title="5.HashMap的扩容"></a>5.HashMap的扩容</h3><p>  当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</p>
<p>  那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">     void resize(int newCapacity) &#123;</span><br><span class="line">       HashMapEntry[] oldTable = table;</span><br><span class="line">       int oldCapacity = oldTable.length;</span><br><span class="line">        //如果当前的数组长度已经达到最大值，则不在进行调整</span><br><span class="line">       if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">//根据传入参数的长度定义新的数组</span><br><span class="line">       HashMapEntry[] newTable = new HashMapEntry[newCapacity];</span><br><span class="line">       //按照新的规则，将旧数组中的元素转移到新数组中</span><br><span class="line">       transfer(newTable);</span><br><span class="line">       table = newTable;</span><br><span class="line">         //更新临界值</span><br><span class="line">       threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>  旧数组的数据转到新数组<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  void transfer(HashMapEntry[] newTable) &#123;</span><br><span class="line">    int newCapacity = newTable.length;</span><br><span class="line">    for (HashMapEntry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        while(null != e) &#123;</span><br><span class="line">            HashMapEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            int i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="6-Fail-Fast机制："><a href="#6-Fail-Fast机制：" class="headerlink" title="6.Fail-Fast机制："></a>6.Fail-Fast机制：</h3><p> 我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。</p>
<p>　　这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。<br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashIterator() &#123;</span><br><span class="line">           expectedModCount = modCount;</span><br><span class="line">           if (size &gt; 0) &#123; // advance to first entry</span><br><span class="line">               HashMapEntry[] t = table;</span><br><span class="line">               while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)</span><br><span class="line">                   ;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>　　<br>在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map：</p>
<p>　　　注意到modCount声明为volatile，保证线程之间修改的可见性。（volatile之所以线程安全是因为被volatile修饰的变量不保存缓存，直接在内存中修改，因此能够保证线程之间修改的可见性）
　　　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">　        final Entry&lt;K,V&gt; nextEntry() &#123;</span><br><span class="line">    if (modCount != expectedModCount)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    HashMapEntry&lt;K,V&gt; e = next;</span><br><span class="line">    if (e == null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line"></span><br><span class="line">    if ((next = e.next) == null) &#123;</span><br><span class="line">        HashMapEntry[] t = table;</span><br><span class="line">        while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line">    current = e;</span><br><span class="line">    return e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　　<br>　　　在HashMap的API中指出：</p>
<p>　　由所有HashMap类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不保证在将来不确定的时间发生任意不确定行为的风险。</p>
<p>　　注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误.</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ul>
<li>第一、使用线程安全的ConcurrentHashMap或HashTable,它就不会产生ConcurrentModificationException异常，也就是它使用迭代器完全不会产生fail-fast机制</li>
<li>第二.Collections.synchronizedMap将HashMap包装起来</li>
</ul>
<p>返回由指定映射支持的同步（线程安全的）映射。为了保证按顺序访问，必须通过返回的映射完成对底层映射的所有访问。在返回的映射或其任意 collection 视图上进行迭代时，强制用户手工在返回的映射上进行同步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map m = Collections.synchronizedMap(new HashMap());</span><br><span class="line">...</span><br><span class="line">Set s = m.keySet();  //不需要加锁</span><br><span class="line">...</span><br><span class="line">synchronized(m) &#123;  // 对Map的对象m加锁</span><br><span class="line">Iterator i = s.iterator(); // 必须加锁的模块</span><br><span class="line">    while (i.hasNext())</span><br><span class="line">        foo(i.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p> <a href="http://www.cnblogs.com/esther-qing/p/6480768.html" target="_blank" rel="noopener">深入Java集合学习系列：HashMap的实现原理</a></p>
<p> <a href="http://blog.csdn.net/vking_wang/article/details/14166593" target="_blank" rel="noopener">HashMap实现原理分析</a></p>
<p> <a href="http://www.cnblogs.com/NewMan13/p/6034140.html" target="_blank" rel="noopener">HashMap, HashTable, CurrentHashMap的区别</a></p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-01-24T09:40:27.917Z" itemprop="dateUpdated">2019-01-24 17:40:27</time>
</span><br>


        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/2017/09/10/HashMap的实现原理/" target="_blank" rel="external">https://www.jianshu.com/u/3e759a2c717f/2017/09/10/HashMap的实现原理/</a>
        
    </div>
    
    <footer>
        <a href="https://www.jianshu.com/u/3e759a2c717f">
            <img src="/img/avater.png" alt="Yaisn Yao">
            Yaisn Yao
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hashmap/">Hashmap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://www.jianshu.com/u/3e759a2c717f/2017/09/10/HashMap的实现原理/&title=《HashMap的实现原理》 — We're here to put a dent in the universe&pic=https://www.jianshu.com/u/3e759a2c717f/img/avater.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.jianshu.com/u/3e759a2c717f/2017/09/10/HashMap的实现原理/&title=《HashMap的实现原理》 — We're here to put a dent in the universe&source=HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.jianshu.com/u/3e759a2c717f/2017/09/10/HashMap的实现原理/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《HashMap的实现原理》 — We're here to put a dent in the universe&url=https://www.jianshu.com/u/3e759a2c717f/2017/09/10/HashMap的实现原理/&via=https://www.jianshu.com/u/3e759a2c717f" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.jianshu.com/u/3e759a2c717f/2017/09/10/HashMap的实现原理/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/10/17/应用开发进阶必经之路之性能优化/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">应用开发进阶必经之路之性能优化</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/09/01/升级Android Studio3.0 beta1问题汇总/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">升级Android Studio3.0 beta1问题汇总</h4>
      </a>
    </div>
  
</nav>



    

















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style="display:none">
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style="display:none">
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Yaisn Yao &copy; 2015 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://www.jianshu.com/u/3e759a2c717f/2017/09/10/HashMap的实现原理/&title=《HashMap的实现原理》 — We're here to put a dent in the universe&pic=https://www.jianshu.com/u/3e759a2c717f/img/avater.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.jianshu.com/u/3e759a2c717f/2017/09/10/HashMap的实现原理/&title=《HashMap的实现原理》 — We're here to put a dent in the universe&source=HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.jianshu.com/u/3e759a2c717f/2017/09/10/HashMap的实现原理/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《HashMap的实现原理》 — We're here to put a dent in the universe&url=https://www.jianshu.com/u/3e759a2c717f/2017/09/10/HashMap的实现原理/&via=https://www.jianshu.com/u/3e759a2c717f" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.jianshu.com/u/3e759a2c717f/2017/09/10/HashMap的实现原理/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://www.jianshu.com/u/3e759a2c717f/2017/09/10/HashMap的实现原理/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = 'YasinYao的个人博客';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
