<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>We&#39;re here to put a dent in the universe</title>
  <icon>https://www.gravatar.com/avatar/d954ca2cf792c3073afcf671ca8fdcc8</icon>
  <subtitle>爱生活，爱编程</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.jianshu.com/u/3e759a2c717f/"/>
  <updated>2019-01-24T09:11:04.847Z</updated>
  <id>https://www.jianshu.com/u/3e759a2c717f/</id>
  
  <author>
    <name>Yaisn Yao</name>
    <email>yasin27878@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>几个Exception分析</title>
    <link href="https://www.jianshu.com/u/3e759a2c717f/2019/01/17/java_lang_IllegalStateException/"/>
    <id>https://www.jianshu.com/u/3e759a2c717f/2019/01/17/java_lang_IllegalStateException/</id>
    <published>2019-01-17T08:07:36.000Z</published>
    <updated>2019-01-24T09:11:04.847Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍几个Exception的产生原因及解决方案<br><a id="more"></a></p><h2 id="java-lang-RuntimeException"><a href="#java-lang-RuntimeException" class="headerlink" title="java.lang.RuntimeException"></a>java.lang.RuntimeException</h2><h4 id="今天在bugly意外发现一个非法状态的异常"><a href="#今天在bugly意外发现一个非法状态的异常" class="headerlink" title="今天在bugly意外发现一个非法状态的异常"></a>今天在bugly意外发现一个非法状态的异常</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException:Unable to destroy activity &#123;com.xxx.xxx/com.xxx.xxx.mvp.orderinfo.ui.OrderInfoActivity&#125;: java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState</span><br></pre></td></tr></table></figure><p>他的意思是 这个动作不能在onSaveInstanceState之后进行操作<br>定位到代码的具体位置是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void hideProgress() &#123;</span><br><span class="line">    if (progressDialog != null) &#123;</span><br><span class="line">        progressDialog.dismiss();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>是上面代码中的progressDialog.dismiss()方法有问题（这是一个DialogFragment）</p><p>也就是系统不允许dialog关闭在onSaveInstanceState之后<br>查了一些资料得到一些信息</p><h3 id="java-lang-IllegalStateException异常产生的原因及解决办法"><a href="#java-lang-IllegalStateException异常产生的原因及解决办法" class="headerlink" title="java.lang.IllegalStateException异常产生的原因及解决办法"></a>java.lang.IllegalStateException异常产生的原因及解决办法</h3><h4 id="错误类型大致为以下几种："><a href="#错误类型大致为以下几种：" class="headerlink" title="错误类型大致为以下几种："></a>错误类型大致为以下几种：</h4><ul><li>java.lang.IllegalStateException：Cannot   forward   a   response   that   is   already   committed </li><li>IllegalStateException：response already commited </li><li>IllegalStateException：getOutputStream() has already been called for this request</li></ul><hr><p>IllegalStateException: Can not perform this action after onSaveInstanceState：</p><p>== 解决办法==：onSaveInstanceState方法是在该Activity即将被销毁前调用，来保存Activity数据的，如果在保存玩状态后</p><h2 id="再给它销毁就会出错。解决办法就是把dismiss（）方法替换成-dismissAllowingStateLoss"><a href="#再给它销毁就会出错。解决办法就是把dismiss（）方法替换成-dismissAllowingStateLoss" class="headerlink" title="再给它销毁就会出错。解决办法就是把dismiss（）方法替换成 dismissAllowingStateLoss()"></a>再给它销毁就会出错。解决办法就是把dismiss（）方法替换成 dismissAllowingStateLoss()</h2><h4 id="错误原因："><a href="#错误原因：" class="headerlink" title="错误原因："></a>错误原因：</h4><p>  该异常表示，当前对客户端的响应已经结束，不能在响应已经结束（或说消亡）后再向客户端（实际上是缓冲区）输出任何内容。<br>  Object is no longer valid to operate on. Was it deleted by another thread?<br>  该异常表示，realmObject对象在其他线程已被删除，在这个线程中使用的时候抛出的异常。</p><h4 id="补充另一种异常情况："><a href="#补充另一种异常情况：" class="headerlink" title="补充另一种异常情况："></a>补充另一种异常情况：</h4><p>这里的异常是：<br>java.lang.IllegalStateException<br>Can’t change tag of fragment d{e183845 #0 d{e183845}}: was d{e183845} now d{e183845 #0 d{e183845}}<br>经查，在显示fragment的代码中使用了：<br>fragment.show(getSupportFragmentManager, fragment.toString());<br>而这里是因为两次toString()结果不同，导致不同的tag指向的是同一个fragment。<br>获取fragment的tag的正确方法应该是使用其提供的fragment.getTag()方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍几个Exception的产生原因及解决方案&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Android/"/>
    
      <category term="RuntimeException" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/RuntimeException/"/>
    
  </entry>
  
  <entry>
    <title>【推荐】好用强大的Android路由框架--Rudolph</title>
    <link href="https://www.jianshu.com/u/3e759a2c717f/2019/01/04/%E3%80%90%E6%8E%A8%E8%8D%90%E3%80%91%E5%A5%BD%E7%94%A8%E5%BC%BA%E5%A4%A7%E7%9A%84Android%E8%B7%AF%E7%94%B1%E6%A1%86%E6%9E%B6--Rudolph/"/>
    <id>https://www.jianshu.com/u/3e759a2c717f/2019/01/04/【推荐】好用强大的Android路由框架--Rudolph/</id>
    <published>2019-01-04T08:07:36.000Z</published>
    <updated>2019-01-24T09:59:15.966Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要说一个好用强大的Android路由框架–Rudolph<br><a id="more"></a></p><p>【推荐】好用强大的Android路由框架–Rudolph</p><p>Rudolph Android Router Framework（鲁道夫安卓路由框架组件）<a href="https://github.com/wzbos/Android-Rudolph-Router">github上查看</a></p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><a href="#1框架特性">1.框架特性</a></li><li><a href="#2依赖方式">2.依赖方式</a></li><li><a href="#3代码混淆">3.代码混淆</a></li><li><a href="#4调用方式">4.调用方式</a></li><li><a href="#5注解说明">5.注解说明</a></li><li><a href="#6组件化">6.组件化</a></li><li><a href="#7常见问题">7.常见问题</a></li></ul><h3 id="1-框架特性"><a href="#1-框架特性" class="headerlink" title="1.框架特性"></a>1.框架特性</h3><ul><li>支持组件API模块自动生成</li><li>自动生成路由Builder类与服务类的接口层；</li><li>加载更快，更稳定，无需dex扫描方式加载；</li><li>无需指定模块名，接入更简单；</li><li>显式跳转与URL路由地址跳转融为一体，更方便快捷；</li><li>通过Builder方式传参，无需手动写参数名，从而减少参数传错和修改带来的Bug隐患；</li><li>支持所有Intent的参数类型；</li><li>支持Activity 、Fragment、Service、Method四种路由类型</li><li>支持Instant Run</li><li>支持AndroidX</li><li>支持Kotlin</li></ul><h3 id="2-依赖方式"><a href="#2-依赖方式" class="headerlink" title="2.依赖方式"></a>2.依赖方式</h3><p>Build.gradle</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  implementation <span class="string">'cn.wzbos.rudolph:rudolph:1.0.1'</span></span><br><span class="line">  annotationProcessor <span class="string">'cn.wzbos.rudolph:rudolph-compiler:1.0.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'kotlin-android'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'kotlin-kapt'</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  implementation <span class="string">'cn.wzbos.rudolph:rudolph:1.0.1'</span></span><br><span class="line">  kapt <span class="string">'cn.wzbos.rudolph:rudolph-compiler:1.0.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-代码混淆"><a href="#3-代码混淆" class="headerlink" title="3.代码混淆"></a>3.代码混淆</h3><p>如果开启了代码混淆，只需要在混淆配置文件中添加如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-keep class * implements cn.wzbos.android.rudolph.IRouteTable&#123;*;&#125;</span><br><span class="line">-keep class * implements cn.wzbos.android.rudolph.IRouteBinder&#123;*;&#125;</span><br><span class="line">-keepclassmembers class ** &#123;</span><br><span class="line">    @cn.wzbos.android.rudolph.annotations.Route &lt;methods&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-调用方式"><a href="#4-调用方式" class="headerlink" title="4.调用方式"></a>4.调用方式</h3><ul><li><a href="#activity">Activity</a></li><li><a href="#fragment">Fragment</a></li><li><a href="#service">Service</a></li><li><a href="#method">Method</a></li></ul><h4 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h4><p>定义一个Activity路由，如果不需要用url方式调用可以不写路由地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Route</span>(<span class="string">"/activity/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Arg</span>(<span class="string">"userId"</span>)</span><br><span class="line">    <span class="keyword">int</span> userId;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Arg</span>(<span class="string">"userName"</span>)</span><br><span class="line">    String userName;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        Rudolph.bind(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用Activity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserActivityRouter.builder().userId(<span class="number">11</span>).userName(<span class="string">"John"</span>).build().start(context);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rudolph.builder(<span class="string">"/user?userId=11&amp;userName=John"</span>).build().open(context);</span><br></pre></td></tr></table></figure><h4 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h4><p>创建一个Fragment路由</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Route</span>(<span class="string">"/fragment/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Arg</span>(<span class="string">"userId"</span>)</span><br><span class="line">    <span class="keyword">int</span> userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span>(<span class="string">"userName"</span>)</span><br><span class="line">    String userName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        Rudolph.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用Fragment</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fragment fragment = TestFragmentRouter.builder().userId(<span class="number">11</span>).userName(<span class="string">"John"</span>).build().open();</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rudolph.builder(<span class="string">"/fragment/user?userId=11&amp;userName=John"</span>).build().open();</span><br></pre></td></tr></table></figure><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>创建一个服务(适用于跨module调用)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Route(vaule=&quot;/service/test&quot;,export = true)</span><br><span class="line">public class TestService implements IRouteService&#123;</span><br><span class="line"></span><br><span class="line">    @Arg</span><br><span class="line">    int userId;</span><br><span class="line"></span><br><span class="line">    @Arg</span><br><span class="line">    String userName;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void init(Bundle bundle) &#123;</span><br><span class="line">        Log.d(&quot;TestService&quot;, &quot;afterInject&quot;);</span><br><span class="line">        rudolph.bind(TestService.this, bundle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Export</span><br><span class="line">    public void showMessage(Context context, String msg) &#123;</span><br><span class="line">        Toast.makeText(context, msg + &quot;\nuserId:&quot; + userId + &quot;,userName:&quot; + userName, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>注意：服务类必须实现IRouteService接口</code></p><p>调用服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ITestService service = TestServiceRouter.builder().userId(<span class="number">1</span>).userName(<span class="string">"Tom"</span>).build().open();</span><br><span class="line">service.showMessage(MainActivity.<span class="keyword">this</span>, <span class="string">"Hello Provider!"</span>);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ITestService service = (ITestService)Rudolph.builder(<span class="string">"/service/test?userId=11&amp;userName=John"</span>).build().open();</span><br><span class="line">service.showMessage(MainActivity.<span class="keyword">this</span>, <span class="string">"Hello Provider!"</span>);</span><br></pre></td></tr></table></figure><h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class TestMethod &#123;</span><br><span class="line">    @Route(&quot;/method/test&quot;)</span><br><span class="line">    public static void Test(@Arg Context context, @Arg int userId, @Arg String userName) &#123;</span><br><span class="line">        Toast.makeText(context, &quot;Hello Method!\nuserId:&quot; + userId + &quot;,userName:&quot; + userName, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rudolph.builder(<span class="string">"/method/test?userId=11&amp;userName=John"</span>).build().open(context);</span><br></pre></td></tr></table></figure><p><code>注意：</code><br><code>1.方法必须为静态方法</code><br><code>2.context是获取open(context)传的上下文，如果调用的时候没context值则接收的值为ApplicationContext</code></p><h3 id="5-注解说明"><a href="#5-注解说明" class="headerlink" title="5.注解说明"></a>5.注解说明</h3><ul><li><a href="#route">@Route</a></li><li><a href="#arg">@Arg</a></li><li><a href="#component">@Component</a></li><li><a href="#export">@Export</a></li></ul><h4 id="Route"><a href="#Route" class="headerlink" title="@Route"></a>@Route</h4><p>此注解为标识一个路由；</p><ul><li>参数：<ul><li>value：路由地址，可为空，例如@Route(“/room”)</li><li>export：是否导出API，一般组件化刚才才会用</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Route</span>(value = <span class="string">"/user"</span>,export = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Arg"><a href="#Arg" class="headerlink" title="@Arg"></a>@Arg</h4><p>此注解为标识路由的参数（注意如果注解到字段上，此字段不能为private）。</p><ul><li>参数：<ul><li>value：路由地址，可为空(默认取字段名)，例如@Arg(“userId”),@Arg(RAW_URI)</li><li>base64：标识此参数是否为base64方式编码</li><li>json：标识此参数是否为json格式</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Route</span>(value = <span class="string">"/user"</span>,export = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"><span class="meta">@Arg</span>(<span class="string">"userId"</span>)</span><br><span class="line"><span class="keyword">int</span> userId;</span><br><span class="line"><span class="meta">@Arg</span></span><br><span class="line">String userName;</span><br><span class="line"><span class="meta">@Arg</span>(value=<span class="string">"userInfo"</span>,base64=<span class="keyword">true</span>, json=<span class="keyword">true</span>)</span><br><span class="line">String userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h4><p>此注解为组件化所需要的注解，主要为提供组件初始化操作；</p><ul><li>参数：无</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestComponent</span> <span class="keyword">implements</span> <span class="title">IRouteTable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Application application)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(application.getApplicationContext(), <span class="string">"组件xxx初始化啦！"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Export"><a href="#Export" class="headerlink" title="@Export"></a>@Export</h4><p>导出注解的方法，此注解只能用在Method上，且此方法必须为非静态(static)的Public方法；</p><ul><li>参数：无</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Route</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> <span class="keyword">implements</span> <span class="title">IRouteService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Export</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-组件化"><a href="#6-组件化" class="headerlink" title="6.组件化"></a>6.组件化</h3><p>场景：<code>A模块</code>需要调用<code>B模块</code></p><p>实现方式：需要导出<code>B模块的API</code>（当然如果想用纯URL的方式调用可以不导出），然后A、B 模块都依赖<code>B模块的API</code></p><h4 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h4><p>第一步：在<code>B模块</code>的的build.gradle中增加如下配置，其中<code>export_api_name</code>为导出的API模块名，<code>export_api_package</code>为导出的API包名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">    javaCompileOptions &#123;</span><br><span class="line">                annotationProcessorOptions &#123;</span><br><span class="line">                    arguments = [</span><br><span class="line">                            export_api_name   : project.getName() + &quot;_api&quot;,</span><br><span class="line">                            export_api_package: &quot;com.xxxx.module_b_api&quot;</span><br><span class="line">                    ]</span><br><span class="line">                    includeCompileClasspath = true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：点击重新编译，然后就能看到生成的API工程，看到API工程后再到settings.gradle中增加以下依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">':module_b_api'</span></span><br></pre></td></tr></table></figure><p>第三步：需要在<code>A模块</code>和<code>B模块</code>中增加依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">        implementation project(<span class="string">':module_b_api'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化组件"><a href="#初始化组件" class="headerlink" title="初始化组件"></a>初始化组件</h4><p>通过以下代码可以初始化每个组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestComponent</span> <span class="keyword">implements</span> <span class="title">IRouteTable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Application application)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(application.getApplicationContext(), <span class="string">"组件xxx初始化啦！"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>（注意：@Component注解的类,每个module中只能存在一个)</code></p><h3 id="7-常见问题"><a href="#7-常见问题" class="headerlink" title="7.常见问题"></a>7.常见问题</h3><ul><li><a href="#路由参数支持的数据类型">路由参数支持哪些数据类型？</a></li><li><a href="#初始化组件">如何初始化组件？</a></li></ul><h4 id="路由参数支持的数据类型"><a href="#路由参数支持的数据类型" class="headerlink" title="路由参数支持的数据类型"></a>路由参数支持的数据类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Route</span>(value = <span class="string">"/activity/test"</span>,export = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Arg</span>(RAW_URI)</span><br><span class="line">    String routeUri;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span>(<span class="string">"stringArg"</span>)</span><br><span class="line">    String stringArg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span>(value = <span class="string">"string64"</span>, base64 = <span class="keyword">true</span>)</span><br><span class="line">    String string64Arg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span>(<span class="string">"stringArray"</span>)</span><br><span class="line">    String[] stringArrayArg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span>(<span class="string">"boolArg"</span>)</span><br><span class="line">    <span class="keyword">boolean</span> boolArg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span>(<span class="string">"booleanArray"</span>)</span><br><span class="line">    <span class="keyword">boolean</span>[] booleanArrayArg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span>(<span class="string">"byteArg"</span>)</span><br><span class="line">    <span class="keyword">byte</span> byteArg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span>(<span class="string">"byteArray"</span>)</span><br><span class="line">    <span class="keyword">byte</span>[] byteArrayArg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span>(<span class="string">"shortArg"</span>)</span><br><span class="line">    <span class="keyword">short</span> shortArg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span>(<span class="string">"shortArray"</span>)</span><br><span class="line">    <span class="keyword">short</span>[] shortArrayArg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span>(<span class="string">"intArg"</span>)</span><br><span class="line">    <span class="keyword">int</span> intArg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span>(<span class="string">"intArrayArg"</span>)</span><br><span class="line">    <span class="keyword">int</span>[] intArrayArg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span>(<span class="string">"longArg"</span>)</span><br><span class="line">    <span class="keyword">long</span> longArg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span>(<span class="string">"longArray"</span>)</span><br><span class="line">    <span class="keyword">long</span>[] longArrayArg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span>(<span class="string">"charArg"</span>)</span><br><span class="line">    <span class="keyword">char</span> charArg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span>(<span class="string">"charArray"</span>)</span><br><span class="line">    <span class="keyword">char</span>[] charArrayArg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span>(<span class="string">"floatArg"</span>)</span><br><span class="line">    <span class="keyword">float</span> floatArg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span>(<span class="string">"floatArray"</span>)</span><br><span class="line">    <span class="keyword">float</span>[] floatArrayArg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span>(<span class="string">"doubleArg"</span>)</span><br><span class="line">    <span class="keyword">double</span> doubleArg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span>(<span class="string">"doubleArray"</span>)</span><br><span class="line">    <span class="keyword">double</span>[] doubleArrayArg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span>(<span class="string">"characterArg"</span>)</span><br><span class="line">    Character characterArg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ArrayList</span></span><br><span class="line">    <span class="meta">@Arg</span></span><br><span class="line">    ArrayList&lt;String&gt; stringArrayListArg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span></span><br><span class="line">    ArrayList&lt;Integer&gt; integerArrayListArg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span>(value = <span class="string">"charSequenceArrayList"</span>)</span><br><span class="line">    ArrayList&lt;CharSequence&gt; charSequenceArrayListArg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span>(value = <span class="string">"parcelableArrayList"</span>)</span><br><span class="line">    ArrayList&lt;Broker&gt; parcelableArrayListArg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span>(value = <span class="string">"serialized"</span>)</span><br><span class="line">    Broker serializedParam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//json</span></span><br><span class="line">    <span class="meta">@Arg</span>(value = <span class="string">"json"</span>, json = <span class="keyword">true</span>)</span><br><span class="line">    User&lt;Broker&gt; jsonParam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//encode：json-&gt;base64，decode：base64-&gt;json</span></span><br><span class="line">    <span class="meta">@Arg</span>(value = <span class="string">"base64json"</span>, json = <span class="keyword">true</span>, base64 = <span class="keyword">true</span>)</span><br><span class="line">    User&lt;Broker&gt; base64jsonParam;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        Rudolph.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/wzbos/Android-Rudolph-Router">github上查看</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要说一个好用强大的Android路由框架–Rudolph&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Android/"/>
    
      <category term="路由" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>6条给React开发者的专业建议</title>
    <link href="https://www.jianshu.com/u/3e759a2c717f/2018/09/07/6%E6%9D%A1%E7%BB%99React%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E4%B8%93%E4%B8%9A%E5%BB%BA%E8%AE%AE/"/>
    <id>https://www.jianshu.com/u/3e759a2c717f/2018/09/07/6条给React开发者的专业建议/</id>
    <published>2018-09-07T08:07:36.000Z</published>
    <updated>2019-01-24T10:11:05.395Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要说6条给React开发者的专业建议,让你写出更好的React代码<br><a id="more"></a></p><h2 id="1-使用方法组件"><a href="#1-使用方法组件" class="headerlink" title="1. 使用方法组件"></a>1. 使用方法组件</h2><p>在你不需要使用组建的内部状态和生命周期方法<br>你可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function welcome(props)&#123;</span><br><span class="line">    return &lt;h1&gt;Hello,&#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>来代替<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Welcome extends Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;h1&gt;Hello,&#123;this.props.name&#125;&lt;/h1&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="使用这种方法的好处"><a href="#使用这种方法的好处" class="headerlink" title="使用这种方法的好处:"></a>使用这种方法的好处:</h5><ul><li>更少的代码,</li><li>更容易理解,</li><li>不用处理状态机,</li><li>测试简单,</li><li>不需要绑定<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- 更容易提取较小的组件</span><br><span class="line"></span><br><span class="line">## 2.尽可能的让你的组件小巧</span><br><span class="line">####  使用这种方法的好处:</span><br><span class="line">- 便于阅读</span><br><span class="line">- 便于测试</span><br><span class="line">- 方便维护</span><br><span class="line">- 方便复用</span><br><span class="line">####  例如:下面我们把个人中心资料模块进行细分</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">个人用户信息部分被拆分</span><br></pre></td></tr></table></figure></li></ul><p>class Comment extends Compont{<br>    render()<br>     <div classname="Comment"><br>        <userinfo user="{this.props.user}/"><br>        <div classname="Comment-text"><br>        {this.props.text}<br>        </div><br>        <div classname="comment-text"><br>        {formatDate(this.props.date)}<br>        </div><br>    </userinfo></div><br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在用户信息部分中,头像部分也被拆分成更小的组件</span><br></pre></td></tr></table></figure></p><p>function UserInfo(props){<br>    renturn (<br>    <div classname="UserInfo"><br>        <avatar user="{props.name}/"><br>        <div classnmae="UserInfo-name"><br>        {props.user.name}<br>        </div><br>    </avatar></div><br>    );<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">个人头像部分</span><br></pre></td></tr></table></figure></p><p>function Avatar(props){<br>    return(<br>    &lt;img className=’Avatar’<br>        src={props.user.avatarUrl}<br>        alt={props.user.name}<br>    <br>    );<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 3.了解并知道怎样处理&apos;this&apos;</span><br><span class="line"></span><br><span class="line">### 1. 在render中绑定</span><br><span class="line"></span><br><span class="line">这种方式虽然简单明了但是有性能问题,因为点击后会调用一个新的函数,每次这个组件都要重新渲染</span><br></pre></td></tr></table></figure></p><p>class HelloWorld extend component{<br>    contructor(props){<br>        super(props);<br>        this.state={message:’Hi’};<br>    }<br>    logMessage(){<br>        console.log(this.state.message);<br>    }<br>    render(){<br>        return {<br>            <input type="button" value="Log" onclick="{this.logMessage.bind(this)}/"><br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">### 2. 在render中使用箭头函数</span><br><span class="line"> </span><br><span class="line"> 这种方式和方法1同样会有相同的性能问题</span><br></pre></td></tr></table></figure></p><p>class HelloWorld extend component{<br>    contructor(props){<br>        super(props);<br>        this.state={message:’Hi’};<br>    }<br>    logMessage(){<br>        console.log(this.state.message);<br>    }<br>    render(){<br>        return {<br>            <input type="button" value="Log" onclick="{()=">this.logMessage}/&gt;<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">### 3. 在构造方法中绑定</span><br><span class="line"></span><br><span class="line"> 这种方式需要记得使用super(props)</span><br></pre></td></tr></table></figure></p><p>class HelloWorld extend component{<br>    contructor(props){<br>        super(props);<br>        this.state={message:’Hi’};<br>        this.logMessage= this.logMessage.bind(this)<br>    }<br>    logMessage(){<br>        console.log(this.state.message);<br>    }<br>    render(){<br>        return {<br>            <input type="button" value="Log" onclick="{this.logMessage}/"><br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">### 4. 在属性中使用箭头函数</span><br><span class="line"> </span><br><span class="line">有方法1和2的性能问题</span><br></pre></td></tr></table></figure></p><p>class HelloWorld extend component{</p><pre><code>this.state={message:&apos;Hi&apos;};logMessage=()=&gt;{    console.log(this.state.message);}render(){    return {        &lt;input type=&apos;button&apos; value=&apos;Log&apos; onClick={this.logMessage}/&gt;    }}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 4.在更新状态时使用方法而不是对象</span><br><span class="line">user:</span><br></pre></td></tr></table></figure></p><p>this.setState((prevState.props)=&gt;{<br>    renturn {correctData:!prevState.correctData}<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">not</span><br></pre></td></tr></table></figure></p><p>this.setState({correctData:!this.state.correctData});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## 5.开发lib时使用&apos;prop-types&apos;</span><br></pre></td></tr></table></figure></p><p>import PropTypes from ‘pros-types’;</p><p>class Welcome extends Component{<br>    render(){<br>        return </p><h1>Hello,{this.props.name}</h1><p></p><pre><code>}</code></pre><p>}<br>Welcome.propTypes={<br>    name:ProsTypes.string.isRequired<br>}<br><code>`</code></p><h2 id="6-使用必要的React-开发工具来帮助我们"><a href="#6-使用必要的React-开发工具来帮助我们" class="headerlink" title="6.使用必要的React 开发工具来帮助我们"></a>6.使用必要的React 开发工具来帮助我们</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要说6条给React开发者的专业建议,让你写出更好的React代码&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="https://www.jianshu.com/u/3e759a2c717f/categories/React/"/>
    
    
      <category term="React" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>APP线上bug处理</title>
    <link href="https://www.jianshu.com/u/3e759a2c717f/2018/09/06/APP%20%E7%BA%BF%E4%B8%8Abug%E5%A4%84%E7%90%86/"/>
    <id>https://www.jianshu.com/u/3e759a2c717f/2018/09/06/APP 线上bug处理/</id>
    <published>2018-09-06T08:07:36.000Z</published>
    <updated>2019-01-24T11:07:40.173Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要说APP在线上bug的处理<br><a id="more"></a></p><h2 id="修复的bug"><a href="#修复的bug" class="headerlink" title="修复的bug"></a>修复的bug</h2><h3 id="1-157-java-lang-NullPointerException"><a href="#1-157-java-lang-NullPointerException" class="headerlink" title="1. #157 java.lang.NullPointerException"></a>1. #157 java.lang.NullPointerException</h3><p>android.os.Parcel.readException(Parcel.java:1690)</p><h5 id="问题分析：这是一个系统内部的空指针，报错是因为MediaScannerConnection-scanFile方法（刷新文件目录的图片显示到相册）；原因是传入的数组中包含一个空路径（删除文件夹导致路径不存在），只用在坚果PRO和坚果PRO2会出错；"><a href="#问题分析：这是一个系统内部的空指针，报错是因为MediaScannerConnection-scanFile方法（刷新文件目录的图片显示到相册）；原因是传入的数组中包含一个空路径（删除文件夹导致路径不存在），只用在坚果PRO和坚果PRO2会出错；" class="headerlink" title="-问题分析：这是一个系统内部的空指针，报错是因为MediaScannerConnection.scanFile方法（刷新文件目录的图片显示到相册）；原因是传入的数组中包含一个空路径（删除文件夹导致路径不存在），只用在坚果PRO和坚果PRO2会出错；"></a>-问题分析：这是一个系统内部的空指针，报错是因为MediaScannerConnection.scanFile方法（刷新文件目录的图片显示到相册）；原因是传入的数组中包含一个空路径（删除文件夹导致路径不存在），只用在坚果PRO和坚果PRO2会出错；</h5><h5 id="问题处理"><a href="#问题处理" class="headerlink" title="- 问题处理"></a>- 问题处理</h5><pre><code>删除空路径</code></pre><h2 id="2-141-java-lang-RuntimeException"><a href="#2-141-java-lang-RuntimeException" class="headerlink" title="2. #141 java.lang.RuntimeException"></a>2. #141 java.lang.RuntimeException</h2><p>com.mgzf.widget.mgbottomwheel.MGBottomWheel$a.a(MGBottomWheel.java:72)</p><h5 id="问题分析："><a href="#问题分析：" class="headerlink" title="-问题分析："></a>-问题分析：</h5><pre><code>这个问题实质上是一个空指针异常，报错的是一个build对象为空导致取字段时空指针异常；字段为空的原因是在Activity的configChanges发生变化时会导致界面重绘，而build字段丢失并没有进行保存</code></pre><h5 id="问题处理："><a href="#问题处理：" class="headerlink" title="-问题处理："></a>-问题处理：</h5><pre><code>-方案一： 在这个MGBottomWheel（Fragment）中增加数据保存（onSaveInstanceState）和恢复的方法（onViewStateRestored），处理configChanges发生变化产生的问题（我采用的此方法）-方案二： 参考dialog的处理方案直接关闭这个弹框；然后在Activity中自行处理是否显示</code></pre><h3 id="3-138-java-lang-RuntimeException"><a href="#3-138-java-lang-RuntimeException" class="headerlink" title="3.#138 java.lang.RuntimeException"></a>3.#138 java.lang.RuntimeException</h3><p>com.mogoroom.broker.user.view.BusinessAreaActivity.a(BusinessAreaActivity.java:157)</p><h5 id="问题分析：这个实际上是一个空指针异常，报错的字段原因是一个配置文件的对象为空，导致取值时报错。经查该对象为网络请求后获取服务器返回对象时才会初始化，问题极大可能出在网络较差时没有能够成功获取后端数据"><a href="#问题分析：这个实际上是一个空指针异常，报错的字段原因是一个配置文件的对象为空，导致取值时报错。经查该对象为网络请求后获取服务器返回对象时才会初始化，问题极大可能出在网络较差时没有能够成功获取后端数据" class="headerlink" title="- 问题分析：这个实际上是一个空指针异常，报错的字段原因是一个配置文件的对象为空，导致取值时报错。经查该对象为网络请求后获取服务器返回对象时才会初始化，问题极大可能出在网络较差时没有能够成功获取后端数据"></a>- 问题分析：这个实际上是一个空指针异常，报错的字段原因是一个配置文件的对象为空，导致取值时报错。经查该对象为网络请求后获取服务器返回对象时才会初始化，问题极大可能出在网络较差时没有能够成功获取后端数据</h5><h5 id="处理方案：无论如何都初始化数据并对对象的字段设置默认值"><a href="#处理方案：无论如何都初始化数据并对对象的字段设置默认值" class="headerlink" title="- 处理方案：无论如何都初始化数据并对对象的字段设置默认值"></a>- 处理方案：无论如何都初始化数据并对对象的字段设置默认值</h5><h3 id="4-166-java-lang-IllegalStateException"><a href="#4-166-java-lang-IllegalStateException" class="headerlink" title="4.#166 java.lang.IllegalStateException"></a>4.#166 java.lang.IllegalStateException</h3><p>com.mogoroom.broker.room.poster.view.BrokerPosterActivity$a.a(BrokerPosterActivity.java:444)</p><h5 id="问题分析：这个是一个Activity被销毁后仍然被调用的问题-具体原因是BrokerPosterActivity页面关闭没有销毁网络请求的disposable-导致回调成功后更新UI导致出错；"><a href="#问题分析：这个是一个Activity被销毁后仍然被调用的问题-具体原因是BrokerPosterActivity页面关闭没有销毁网络请求的disposable-导致回调成功后更新UI导致出错；" class="headerlink" title="-问题分析：这个是一个Activity被销毁后仍然被调用的问题,具体原因是BrokerPosterActivity页面关闭没有销毁网络请求的disposable  导致回调成功后更新UI导致出错；"></a>-问题分析：这个是一个Activity被销毁后仍然被调用的问题,具体原因是BrokerPosterActivity页面关闭没有销毁网络请求的disposable  导致回调成功后更新UI导致出错；</h5><h5 id="问题处理-1"><a href="#问题处理-1" class="headerlink" title="- 问题处理"></a>- 问题处理</h5><pre><code>关闭页面时关闭disposable </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要说APP在线上bug的处理&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Android/"/>
    
      <category term="Bug" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Bug/"/>
    
  </entry>
  
  <entry>
    <title>CoordinatorLayout使用解析</title>
    <link href="https://www.jianshu.com/u/3e759a2c717f/2018/09/03/CoordinatorLayout%E4%BD%BF%E7%94%A8%E8%A7%A3%E6%9E%90/"/>
    <id>https://www.jianshu.com/u/3e759a2c717f/2018/09/03/CoordinatorLayout使用解析/</id>
    <published>2018-09-03T08:07:36.000Z</published>
    <updated>2019-01-24T10:08:24.360Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要说CoordinatorLayout使用<br><a id="more"></a></p><h1 id="CoordinatorLayout使用解析"><a href="#CoordinatorLayout使用解析" class="headerlink" title="CoordinatorLayout使用解析"></a>CoordinatorLayout使用解析</h1><h2 id="一-CoordinatorLayout介绍"><a href="#一-CoordinatorLayout介绍" class="headerlink" title="一. CoordinatorLayout介绍"></a>一. CoordinatorLayout介绍</h2><h3 id="1-CoordinatorLayout是一个“加强版”FrameLayout，"><a href="#1-CoordinatorLayout是一个“加强版”FrameLayout，" class="headerlink" title="1.　CoordinatorLayout是一个“加强版”FrameLayout，"></a>1.　CoordinatorLayout是一个“加强版”FrameLayout，</h3><p>它主要有两个用途：</p><ol><li>用作应用的顶层布局管理器，也就是作为用户界面中所有UI控件的容器</li><li>用作相互之间距有特定交互行为的UI控件的容器<br>通过为CoordinatorLayout的子View指定Behavior，就可以实现它们之间的交互行为。<br>Behavior可以用来实现一系列的交互行为和布局变化，比如说侧滑菜单、可滑动删除的UI元素，以及跟随着其他UI控件移动的按钮等。<h4 id="2-文字不够形象，-直接来欣赏一下facebook的效果"><a href="#2-文字不够形象，-直接来欣赏一下facebook的效果" class="headerlink" title="2.文字不够形象， 直接来欣赏一下facebook的效果"></a>2.文字不够形象， 直接来欣赏一下facebook的效果</h4><img src="https://upload-images.jianshu.io/upload_images/1018039-920fa0d9d86fa68b.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="image"><h4 id="3-CoordinatorLayout的使用"><a href="#3-CoordinatorLayout的使用" class="headerlink" title="3. CoordinatorLayout的使用"></a>3. CoordinatorLayout的使用</h4>使用CoordinatorLayout需要在Gradle加入Support Design Library：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.android.support:appcompat-v7:26.1.0&apos;</span><br></pre></td></tr></table></figure></li></ol><h2 id="二-AppBarLayout-CollapsingToolbarLayout的使用"><a href="#二-AppBarLayout-CollapsingToolbarLayout的使用" class="headerlink" title="二.AppBarLayout, CollapsingToolbarLayout的使用"></a>二.AppBarLayout, CollapsingToolbarLayout的使用</h2><h3 id="1-AppBarLayout-CollapsingToolbarLayout是为了配合CoordinatorLayout使用而简单实现相互关系的控件"><a href="#1-AppBarLayout-CollapsingToolbarLayout是为了配合CoordinatorLayout使用而简单实现相互关系的控件" class="headerlink" title="1.AppBarLayout,CollapsingToolbarLayout是为了配合CoordinatorLayout使用而简单实现相互关系的控件"></a>1.AppBarLayout,CollapsingToolbarLayout是为了配合CoordinatorLayout使用而简单实现相互关系的控件</h3><h4 id="2-AppBarLayout-官方文档"><a href="#2-AppBarLayout-官方文档" class="headerlink" title="2.AppBarLayout 官方文档"></a>2.AppBarLayout <a href="https://developer.android.google.cn/reference/android/support/design/widget/AppBarLayout" target="_blank" rel="noopener">官方文档</a></h4><h5 id="1-AppBarLayout-介绍："><a href="#1-AppBarLayout-介绍：" class="headerlink" title="1). AppBarLayout 介绍："></a>1). AppBarLayout 介绍：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 实现了material designs 滑动手势</span><br><span class="line">- AppBarLayout的子View应该通过&#123;setScrollFlags(int)&#125;或者相关的布局xml属性&#123;app：layout_scrollFlags&#125;提供他们想要的滚动行为。</span><br><span class="line">- 最好作为CoordinatorLayou的直接子View使用</span><br><span class="line">- 要拥有一个可滚动的兄弟View并且通过为可滚动的兄弟View设置ScrollingViewBehavior实例来实现绑定。</span><br></pre></td></tr></table></figure><h5 id="2-AppBarLayout滑动区域-查看"><a href="#2-AppBarLayout滑动区域-查看" class="headerlink" title="2).AppBarLayout滑动区域  查看"></a>2).AppBarLayout滑动区域  <a href="https://material.io/guidelines/patterns/scrolling-techniques.html" target="_blank" rel="noopener">查看</a></h5><p>当设计滚动行为时，App bar包含构成滚动结构的四个主要区域（称为块）：</p><ul><li>Status bar</li><li>Tool bar</li><li>Tab bar/search bar</li><li>Flexible space: 用来容纳图像或者扩展app bar的期望宽高比<h5 id="3-滑动类型"><a href="#3-滑动类型" class="headerlink" title="3) 滑动类型"></a>3) 滑动类型</h5>AppBarLayout里面的View都是通过设置app:layout_scrollFlags属性控制滑动，Google提供了5种滑动表现类型，分别是<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- scroll：表示向下滚动的时候，设置了这个属性的View会被滚出屏幕范围，直到消失</span><br><span class="line">- enterAlways：表示向上滚动的时候，设置了这个属性的View会随着滚动手势逐渐出现，直到恢复原来设置的位置(需搭配scroll使用)</span><br><span class="line"></span><br><span class="line">- enterAlwaysCollapsed：是enterAlways的附加选项，一般跟enterAlways一起使用，它是指，View在往下“出现”的时候，首先是enterAlways效果，当View的高度达到最小高度时，View就暂时不去往下滚动，直到ScrollView滑动到顶部不再滑动时，View再继续往下滑动，直到滑到View的顶部结束。</span><br><span class="line"></span><br><span class="line">- exitUntilCollapsed：值设为exitUntilCollapsed的View，当这个View要往上逐渐“消逝”时，会一直往上滑动，直到剩下的的高度达到它的最小高度后，再响应ScrollView的内部滑动事件(需搭配scroll使用)</span><br><span class="line">- snap 表示在滑动过程中如果停止滑动，则头部会就近折叠（要么恢复原状，要么折叠成一个Toolbar或者不显示）(需搭配scroll使用)</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-重要的监听方法"><a href="#4-重要的监听方法" class="headerlink" title="4)重要的监听方法"></a>4)重要的监听方法</h5><p>addOnOffsetChangedListener()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appBarLayout.addOnOffsetChangedListener(new AppBarLayout.OnOffsetChangedListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onOffsetChanged(AppBarLayout appBarLayout, int verticalOffset) &#123;</span><br><span class="line">          // TODO</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="3-CollapsingToolbarLayout-官方文档"><a href="#3-CollapsingToolbarLayout-官方文档" class="headerlink" title="3.CollapsingToolbarLayout 官方文档"></a>3.CollapsingToolbarLayout <a href="https://developer.android.google.cn/reference/android/support/design/widget/CollapsingToolbarLayout" target="_blank" rel="noopener">官方文档</a></h3><h5 id="1-CollapsingToolbarLayout-介绍："><a href="#1-CollapsingToolbarLayout-介绍：" class="headerlink" title="1.)CollapsingToolbarLayout 介绍："></a>1.)CollapsingToolbarLayout 介绍：</h5><p>CollapsingToolbarLayout是实现一个可以折叠的Toolbar，作为AppbarLayout的直接子View使用，CollapsingToolbarLayout控件提供了一下功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 折叠标题：当标题栏较大的时候，在布局完全显示的情况下可以显示标题栏，但是标题栏折叠、变小或者布局滚动出屏幕的时候，可以通过setTitle(CharSequence)设置标题显示，通过设置collapsedTextAppearance和expandedTextAppearance属性可以调整标题栏的外观。</span><br><span class="line"></span><br><span class="line">- 内容遮罩：通过 setContentScrim(Drawable)更改当滚动到临界点的时候显示或者隐藏</span><br><span class="line"></span><br><span class="line">- 状态栏遮罩：可以通过setStatusBarScrim(Drawable)设置遮罩在滚动到临界点之后是显示还是隐藏，必须要在5.0以后设置了fitSystemWindows属性才可以使用</span><br><span class="line"></span><br><span class="line">- 视差滚动子视图：子视图可以在这个视差范围内滚动，See COLLAPSE_MODE_PARALLAX and setParallaxMultiplier(float).</span><br><span class="line"></span><br><span class="line">- 寄托子视图：子视图可以选择在全局范围内被固定，当实现一个折叠的时候，允许Toolbar被固定在合适的位置，详细见COLLAPSE_MODE_PIN</span><br></pre></td></tr></table></figure></p><h5 id="2-折叠塌陷的属性collapseMode"><a href="#2-折叠塌陷的属性collapseMode" class="headerlink" title="2) 折叠塌陷的属性collapseMode"></a>2) 折叠塌陷的属性collapseMode</h5><p>app:layout_collapseMode=”pin”属性：这个属性是设置折叠的模式，Android提供有两个值，分别是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- pin：设置这个值，当CollapsingToolbarLayout完全折叠之后，View还会显示在屏幕上</span><br><span class="line"></span><br><span class="line">- parallax：设置这个值，在内容滚动时，CollapsingToolbarLayout中的View（比如我们这里的ImageView)也会同时滚动，实现视差滚动效果，通常和layout_collapseParallaxMultiplier(设置视差因子)搭配使用。</span><br></pre></td></tr></table></figure></p><ul><li><p>app:layout_collapseParallaxMultiplier=”0.7”属性：设置视差滚动因子，值得范围是0~1.</p></li><li><p>视差滚动因子数值越大，视觉差越大</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 如果这里的值为0，则在头部折叠的过程中，ImageView的顶部在慢慢隐藏，底部不动</span><br><span class="line">- 如果这里的值为1，ImageView的顶部不懂，底部慢慢隐藏，</span><br><span class="line">- 如果这里的取值为0～1之间，则在折叠的过程中，ImageView的顶部和底部都会隐藏，但是头部和底部隐藏的快慢是不一样的，具体速度和视觉乘数有关</span><br></pre></td></tr></table></figure></li></ul><p>简单来说 0~1代表上下方向折叠的快慢 0上部折叠速度快 1下部折叠速度快</p><h2 id="三-Behavior"><a href="#三-Behavior" class="headerlink" title="三.Behavior"></a>三.Behavior</h2><h3 id="1-Behavior介绍"><a href="#1-Behavior介绍" class="headerlink" title="1.Behavior介绍"></a>1.Behavior介绍</h3><h5 id="1-作用于CoordinatorLayout的子View的交互行为插件。"><a href="#1-作用于CoordinatorLayout的子View的交互行为插件。" class="headerlink" title="1.作用于CoordinatorLayout的子View的交互行为插件。"></a>1.作用于CoordinatorLayout的子View的交互行为插件。</h5><p>一个Behavior 实现了用户的一个或者多个交互行为，它们可能包括拖拽、滑动、快滑或者其他一些手势。</p><h5 id="2-Behavior-是一个顶层抽象类，其他的一些具体行为的Behavior-都是继承自这个类。"><a href="#2-Behavior-是一个顶层抽象类，其他的一些具体行为的Behavior-都是继承自这个类。" class="headerlink" title="2. Behavior 是一个顶层抽象类，其他的一些具体行为的Behavior 都是继承自这个类。"></a>2. Behavior 是一个顶层抽象类，其他的一些具体行为的Behavior 都是继承自这个类。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static abstract class Behavior&lt;V extends View&gt; &#123;</span><br><span class="line"></span><br><span class="line">        public Behavior() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Behavior(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">       //省略了若干方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有一个泛型，它的作用是指定要使用这个Behavior的View的类型，可以是Button、TextView等等。</p><h5 id="3-自定义Behavior可以选择重写以下的几个重要方法"><a href="#3-自定义Behavior可以选择重写以下的几个重要方法" class="headerlink" title="3.自定义Behavior可以选择重写以下的几个重要方法:"></a>3.自定义Behavior可以选择重写以下的几个重要方法:</h5><p>-</p><pre><code>- **layoutDependsOn()**：确定使用Behavior的View要依赖的View的类型- **onDependentViewChanged()**：当被依赖的View状态改变时调用- **onDependentViewRemoved()**：当被依赖的View移除时调用- **onStartNestedScroll()**：嵌套滑动开始（ACTION_DOWN），确定Behavior是否要监听此次事件- **onNestedScrollAccepted()** :  onStartNestedScroll返回true才会触发这个方法，接受滚动处理后回调，可以在这个方法里做一些准备工作，如一些状态的重置等。- **onStopNestedScroll()**：嵌套滑动结束（ACTION_UP或ACTION_CANCEL）- **onNestedPreScroll()**：嵌套滑动进行中，要监听的子 View将要滑动，滑动事件即将被消费（但最终被谁消费，可以通过代码控制）- **onNestedScroll()**：嵌套滑动进行中，要监听的子 View的滑动事件已经被消费- **onNestedFling()**：要监听的子 View在快速滑动中- **onNestedPreFling()**：要监听的子View即将快速滑动- **onLayoutChild** 确定使用Behavior的View位置</code></pre><h3 id="2-绑定Behavior的三种方式"><a href="#2-绑定Behavior的三种方式" class="headerlink" title="2.绑定Behavior的三种方式"></a>2.绑定Behavior的三种方式</h3><p>Behavior无法独立完成工作，必须与实际调用的CoordinatorLayout子视图相绑定。具体有三种方式：通过代码绑定、在XML中绑定或者通过注释实现自动绑定。</p><h5 id="1-通过代码绑定Behavior"><a href="#1-通过代码绑定Behavior" class="headerlink" title="1. 通过代码绑定Behavior"></a>1. 通过代码绑定Behavior</h5><p>如果将Behavior当作绑定到CoordinatorLayout中每个视图的附加数据，那么发现Behavior实际上是存储在各个视图的LayoutParams中也就不足为奇了（之前有关于布局的博文）。也是因此，Behavior需要绑定到CoordinatorLayout的直接子项中，因为只有那些子项会包含LayoutParams的特定Behavior子类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TitleBehavior titleBehavior = new TitleBehavior();</span><br><span class="line">CoordinatorLayout.LayoutParams params = (CoordinatorLayout.LayoutParams) yourView.getLayoutParams();</span><br><span class="line">params.setBehavior(titleBehavior);</span><br></pre></td></tr></table></figure><h5 id="2-app-layout-behavior布局属性"><a href="#2-app-layout-behavior布局属性" class="headerlink" title="2. app:layout_behavior布局属性"></a>2. app:layout_behavior布局属性</h5><p>在布局中设置，值为自定义 Behavior类的名字字符串（包含路径）</p><p>有两种写法，包含包名的全路径和以”.”开头的省略项目包名的路径:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;</span><br><span class="line">app:layout_behavior=&quot;com.yasin.coordinatorlayoutdemo.TitleBehavior&quot;</span><br><span class="line">app:layout_behavior=&quot;.TitleBehavior&quot;</span><br></pre></td></tr></table></figure></p><h5 id="3-CoordinatorLayout-DefaultBehavior类注解"><a href="#3-CoordinatorLayout-DefaultBehavior类注解" class="headerlink" title="3. @CoordinatorLayout.DefaultBehavior类注解"></a>3. @CoordinatorLayout.DefaultBehavior类注解</h5><p>在需要使用 Behavior的控件源码定义中添加该注解，然后通过反射机制获取。系统的 AppBarLayout、 FloatingActionButton都采用了这种方式，所以无需在布局中重复设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@CoordinatorLayout.DefaultBehavior(TitleBehavior.class)</span><br><span class="line">public class TitleLayout extends FrameLayout &#123;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-Behavior实现View间交互的原理"><a href="#3-Behavior实现View间交互的原理" class="headerlink" title="3.Behavior实现View间交互的原理"></a>3.Behavior实现View间交互的原理</h3><p>behavior像是view的一个属性，其实它是view的LayoutParam的一个属性，就像宽高一样。当然不是任何一个view的LayoutParam都有这个属性的，只有LayoutParam为android.support.design.widget.CoordinatorLayout.LayoutParams才有这个属性.</p><p>所以，就是只有CoordinatorLayout的子view的LayoutParam可以设置behavior。</p><ul><li>我们可以在CoordinatorLayout.LayoutParams中找到Behavior属性.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static class LayoutParams extends ViewGroup.MarginLayoutParams &#123;</span><br><span class="line">        Behavior mBehavior;</span><br><span class="line">        boolean mBehaviorResolved = false;</span><br><span class="line">        ...</span><br><span class="line">        final Rect mLastChildRect = new Rect();</span><br><span class="line">        &#125;</span><br><span class="line"> ```       </span><br><span class="line">       </span><br><span class="line">##### 1.Behavior初始化过程</span><br><span class="line"> 1. xml方式:app:layout_behavior=”com.yasin.coordinatorlayoutdemo.TitleBehavior”</span><br><span class="line"></span><br><span class="line"> infate的时候，会根据xml去构造LayoutParams，所以我们可以在CoordinatorLayout.LayoutParams看到behavior的初始化过程</span><br></pre></td></tr></table></figure></li></ul><p>LayoutParams(Context context, AttributeSet attrs) {<br>    super(context, attrs);</p><pre><code>final TypedArray a = context.obtainStyledAttributes(attrs,        R.styleable.CoordinatorLayout_LayoutParams);...mBehaviorResolved = a.hasValue(        R.styleable.CoordinatorLayout_LayoutParams_layout_behavior);if (mBehaviorResolved) {    mBehavior = parseBehavior(context, attrs, a.getString(            R.styleable.CoordinatorLayout_LayoutParams_layout_behavior));}a.recycle();</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2.注解方式:@CoordinatorLayout.DefaultBehavior(FloatingActionButton.Behavior.class)</span><br><span class="line"></span><br><span class="line">在CoordinatorLayout的onMeasure的时候会调用prepareChildren，进而调用getResolvedLayoutParams，在getResolvedLayoutParams里会把注解里的默认Behavior赋值给mBehavior,主要代码如下:</span><br></pre></td></tr></table></figure></p><p>LayoutParams getResolvedLayoutParams(View child) {<br>        final LayoutParams result = (LayoutParams) child.getLayoutParams();<br>        //如果xml内写了behavior，此时result.mBehaviorResolved就为true，不会进去<br>        if (!result.mBehaviorResolved) {<br>            Class&lt;?&gt; childClass = child.getClass();<br>            DefaultBehavior defaultBehavior = null;<br>            while (childClass != null &amp;&amp;<br>                    (defaultBehavior = childClass.getAnnotation(DefaultBehavior.class)) == null) {<br>                childClass = childClass.getSuperclass();<br>            }<br>            if (defaultBehavior != null) {<br>                try {<br>                    result.setBehavior(defaultBehavior.value().newInstance());<br>                } catch (Exception e) {<br>                    Log.e(TAG, “Default behavior class “ + defaultBehavior.value().getName() +<br>                            “ could not be instantiated. Did you forget a default constructor?”, e);<br>                }<br>            }<br>            result.mBehaviorResolved = true;<br>        }<br>        return result;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 2.Behavior是如何发挥作用的</span><br><span class="line">measure和layout是Android绘制视图的关键组件，因此Behavior只有在onMeasureChild()和onLayoutChild()回调前拦截父视图的measure和layout，才能达到预计的效果。</span><br><span class="line"></span><br><span class="line">我们再来看看onMeasure的代码，和Behavior相关的主要看prepareChildren和ensurePreDrawListener两个方法</span><br></pre></td></tr></table></figure></p><p>@Override<br>    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {<br>        prepareChildren();<br>        ensurePreDrawListener();<br>        。。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**先看  preareChildren()**</span><br></pre></td></tr></table></figure></p><p> private void prepareChildren() {<br>         //清空mDependencySortedChildren<br>        mDependencySortedChildren.clear();<br>        for (int i = 0, count = getChildCount(); i &lt; count; i++) {<br>            final View child = getChildAt(i);</p><pre><code>        final LayoutParams lp = getResolvedLayoutParams(child);        lp.findAnchorView(this, child);        //加入child        mDependencySortedChildren.add(child);    }      // Finally add the sorted graph list to our list    mDependencySortedChildren.addAll(mChildDag.getSortedList());    // 我们还需要反转结果，因为我们希望列表的开头包含没有依赖项的视图，然后在此之后依赖视图。    Collections.reverse(mDependencySortedChildren);}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prepareChildren内主要是搞出来一个mDependencySortedChildren,根据依赖关系对child进行排序。先把mDependencySortedChildren clear，然后遍历子view，全部加入到mDependencySortedChildren内，最后对mDependencySortedChildren进行排序</span><br><span class="line"></span><br><span class="line">排序这块没看懂.看了翻译和别的文档大概意思是:被依赖的view放前面，依赖的view放后面.  比如我们fab依赖于snackbar，那么snackbar必然放在fab的前边。这么排序有什么用？其实是提高一点效率，后文会说的。</span><br><span class="line"></span><br><span class="line">**次看ensurePreDrawListener()**</span><br></pre></td></tr></table></figure><p>void ensurePreDrawListener() {<br>         //判断是否存在依赖关系<br>        boolean hasDependencies = false;<br>        final int childCount = getChildCount();<br>        for (int i = 0; i &lt; childCount; i++) {<br>            final View child = getChildAt(i);<br>            if (hasDependencies(child)) {<br>                hasDependencies = true;<br>                break;<br>            }<br>        }</p><pre><code>    if (hasDependencies != mNeedsPreDrawListener) {        if (hasDependencies) {            //加入PreDrawListener            addPreDrawListener();        } else {            removePreDrawListener();        }    }}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在prepareChildren确定mDependencySortedChildren之后，会执行ensurePreDrawListener，在这里写判断下CoordinatorLayout的子view是否存在依赖关系，如果存在的话就hasDependencies为true，后边会加入OnPreDrawListener,也就是监听依赖View的布局变化</span><br><span class="line">就是在重绘之前，会调用OnPreDrawListener的onPreDraw方法。再在onPreDraw里面调用了onChildViewsChanged。</span><br><span class="line"></span><br><span class="line">**再看onChildViewsChanged()**</span><br></pre></td></tr></table></figure><p>final void onChildViewsChanged(@DispatchChangeEvent final int type) {<br>                ……..<br>        final int childCount = mDependencySortedChildren.size();<br>        for (int i = 0; i &lt; childCount; i++) {<br>        ….<br>            // Update any behavior-dependent views for the change<br>            for (int j = i + 1; j &lt; childCount; j++) {<br>                final View checkChild = mDependencySortedChildren.get(j);<br>                final LayoutParams checkLp = (LayoutParams) checkChild.getLayoutParams();<br>                final Behavior b = checkLp.getBehavior();</p><pre><code>            if (b != null &amp;&amp; b.layoutDependsOn(this, checkChild, child)) {                if (type == EVENT_PRE_DRAW &amp;&amp; checkLp.getChangedAfterNestedScroll()) {                    // If this is from a pre-draw and we have already been changed                    // from a nested scroll, skip the dispatch and reset the flag                    checkLp.resetChangedAfterNestedScroll();                    continue;                }                final boolean handled;                switch (type) {                    case EVENT_VIEW_REMOVED:                        // EVENT_VIEW_REMOVED means that we need to dispatch                        // onDependentViewRemoved() instead                        b.onDependentViewRemoved(this, checkChild, child);                        handled = true;                        break;                    default:                        // Otherwise we dispatch onDependentViewChanged()                        handled = b.onDependentViewChanged(this, checkChild, child);                        break;                }        }.......}</code></pre><p><code>`</code></p><p>显然从这里就开始触发View的交互了 </p><p>onDependentViewRemoved()和onDependentViewChanged()方法</p><h2 id="四-自定义Behavior"><a href="#四-自定义Behavior" class="headerlink" title="四.自定义Behavior"></a>四.自定义Behavior</h2><p>通常自定义Behavior分为两种情况：</p><ul><li><h4 id="1-通过监听一个View的状态，如位置、大小的变化，来改变其他View的行为，这种只需要重写2个方法就可以了，分别是layoutDependsOn-和onDependentViewChanged-layoutDependsOn方法判断是指定依赖的View时，返回true-然后在onDependentViewChanged-里，被依赖的View做需要的行为动作。"><a href="#1-通过监听一个View的状态，如位置、大小的变化，来改变其他View的行为，这种只需要重写2个方法就可以了，分别是layoutDependsOn-和onDependentViewChanged-layoutDependsOn方法判断是指定依赖的View时，返回true-然后在onDependentViewChanged-里，被依赖的View做需要的行为动作。" class="headerlink" title="1.通过监听一个View的状态，如位置、大小的变化，来改变其他View的行为，这种只需要重写2个方法就可以了，分别是layoutDependsOn 和onDependentViewChanged, layoutDependsOn方法判断是指定依赖的View时，返回true,然后在onDependentViewChanged 里，被依赖的View做需要的行为动作。"></a>1.通过监听一个View的状态，如位置、大小的变化，来改变其他View的行为，这种只需要重写2个方法就可以了，分别是layoutDependsOn 和onDependentViewChanged, layoutDependsOn方法判断是指定依赖的View时，返回true,然后在onDependentViewChanged 里，被依赖的View做需要的行为动作。</h4></li></ul><ul><li><h4 id="2-是重写onStartNestedScroll、onNestedPreScroll、onNestedScroll等一系列方法-可以实现比较复杂的方法"><a href="#2-是重写onStartNestedScroll、onNestedPreScroll、onNestedScroll等一系列方法-可以实现比较复杂的方法" class="headerlink" title="2.是重写onStartNestedScroll、onNestedPreScroll、onNestedScroll等一系列方法.可以实现比较复杂的方法"></a>2.是重写onStartNestedScroll、onNestedPreScroll、onNestedScroll等一系列方法.可以实现比较复杂的方法</h4></li><li><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2></li></ul><p>Android 详细分析AppBarLayout的五种ScrollFlags<a href="https://www.jianshu.com/p/7caa5f4f49bd" target="_blank" rel="noopener">链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要说CoordinatorLayout使用&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Android/"/>
    
      <category term="CoordinatorLayout" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/CoordinatorLayout/"/>
    
  </entry>
  
  <entry>
    <title>React Native 入门</title>
    <link href="https://www.jianshu.com/u/3e759a2c717f/2018/08/10/%20React%20Native%20%E5%85%A5%E9%97%A8/"/>
    <id>https://www.jianshu.com/u/3e759a2c717f/2018/08/10/ React Native 入门/</id>
    <published>2018-08-10T08:07:36.000Z</published>
    <updated>2019-01-24T11:06:24.532Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要说React Native 入门的一些东西，帮助新手快速入门<br><a id="more"></a></p><h1 id="React-Native-入门"><a href="#React-Native-入门" class="headerlink" title="React Native 入门"></a>React Native 入门</h1><h2 id="一-背景"><a href="#一-背景" class="headerlink" title="一. 背景"></a>一. 背景</h2><h3 id="为什么需要React-Native？"><a href="#为什么需要React-Native？" class="headerlink" title="为什么需要React-Native？"></a>为什么需要React-Native？</h3><p>在React-Native出现之前移动端主流的开发模式是原生开发和Hybrid开发（H5混合原生开发），Hybrid app相较于native app的优势是开发成本低开发速度快(H5页面开发跨平台，无需重新写web、android、ios代码)，尽管native app在开发上需要更多时间，但却带来了更好的用户体验(页面渲染、手势操作的流畅性)，也正是基于这两点Facebook在2015年推出了React-Native</p><p>React-Native的开发既保留了React的开发效率又拥有媲美原生的用户体验，其运行原理并非使用webview所以不属于Hybrid开发，想了解的可以查看React Native运行原理解析这篇文章。React-Native提出的理念是‘learn once，write every where’，之所以不是‘learn once, run every where’，是因为不同平台的用户体验有所不同，因此要运行全平台仍需要一些额外的适配</p><h2 id="二-搭建环境"><a href="#二-搭建环境" class="headerlink" title="二. 搭建环境"></a>二. 搭建环境</h2><p>更多更详细搭建流程 <a href="https://reactnative.cn/docs/getting-started.html" target="_blank" rel="noopener">https://reactnative.cn/docs/getting-started.html</a></p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>必须安装的依赖有：Node、Watchman 和 React Native 命令行工具以及 JDK 和 Android Studio。</p><h4 id="1-Node-Watchman"><a href="#1-Node-Watchman" class="headerlink" title="1.Node, Watchman"></a>1.Node, Watchman</h4><p>我们推荐使用Homebrew来安装 Node 和 Watchman。在命令行中执行下列命令安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br><span class="line">brew install watchman</span><br></pre></td></tr></table></figure><p>Node，需要在 v8.3 以上</p><p>Watchman则是由 Facebook 提供的监视文件系统变更的工具。安装此工具可以提高开发时的性能（packager 可以快速捕捉文件的变化从而实现实时刷新）。</p><h4 id="2-Yarn、React-Native-的命令行工具（react-native-cli）"><a href="#2-Yarn、React-Native-的命令行工具（react-native-cli）" class="headerlink" title="2.Yarn、React Native 的命令行工具（react-native-cli）"></a>2.Yarn、React Native 的命令行工具（react-native-cli）</h4><p>Yarn是 Facebook 提供的替代 npm 的工具，可以加速 node 模块的下载。React Native 的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn react-native-cli</span><br></pre></td></tr></table></figure></p><h4 id="3-JDK、Android-Studio的安装"><a href="#3-JDK、Android-Studio的安装" class="headerlink" title="3.JDK、Android Studio的安装"></a>3.JDK、Android Studio的安装</h4><p>略</p><h4 id="4-创建新项目"><a href="#4-创建新项目" class="headerlink" title="4.创建新项目"></a>4.创建新项目</h4><p>使用 React Native 命令行工具来创建一个名为”AwesomeProject”的新项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native init AwesomeProject</span><br></pre></td></tr></table></figure><p>提示：你可以使用–version参数（注意是两个杠）创建指定版本的项目。例如react-native init MyApp –version 0.44.3。注意版本号必须精确到两个小数点。</p><h2 id="三-编译并运行-React-Native-应用"><a href="#三-编译并运行-React-Native-应用" class="headerlink" title="三.编译并运行 React Native 应用"></a>三.编译并运行 React Native 应用</h2><h3 id="1-启动项目"><a href="#1-启动项目" class="headerlink" title="1.启动项目"></a>1.启动项目</h3><p>确保你先运行了模拟器或者连接了真机，然后在你的项目目录中运行<br>react-native run-android：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd AwesomeProject</span><br><span class="line"></span><br><span class="line">react-native run-android</span><br></pre></td></tr></table></figure><p>如果配置没有问题，你应该可以看到应用自动安装到设备上并开始运行。注意第一次运行时需要下载大量编译依赖，耗时可能数十分钟。此过程严重依赖稳定的翻墙工具，否则将频繁遭遇链接超时和断开，导致无法运行。</p><h3 id="2-修改项目"><a href="#2-修改项目" class="headerlink" title="2.修改项目"></a>2.修改项目</h3><p>现在你已经成功运行了项目，我们可以开始尝试动手改一改了：</p><p>使用你喜欢的文本编辑器打开App.js并随便改上几行<br>按两下 R 键，或是用 Menu 键（通常是 F2，在 Genymotion 模拟器中是⌘+M）打开开发者菜单，然后选择 Reload JS 就可以看到你的最新修改。</p><h2 id="四-集成RN到现有的应用"><a href="#四-集成RN到现有的应用" class="headerlink" title="四.集成RN到现有的应用"></a>四.集成RN到现有的应用</h2><p>集成方式 <a href="https://reactnative.cn/docs/integration-with-existing-apps/" target="_blank" rel="noopener">https://reactnative.cn/docs/integration-with-existing-apps/</a></p><h2 id="五-基本的JSX和ES6语法"><a href="#五-基本的JSX和ES6语法" class="headerlink" title="五.基本的JSX和ES6语法"></a>五.基本的JSX和ES6语法</h2><p>先看一下运行成功后的界面代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Sample React Native App</span><br><span class="line"> * https://github.com/facebook/react-native</span><br><span class="line"> * @flow</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import React, &#123;Component&#125; from &apos;react&apos;;</span><br><span class="line">import &#123;</span><br><span class="line">    Platform,</span><br><span class="line">    StyleSheet,</span><br><span class="line">    Text,</span><br><span class="line">    View</span><br><span class="line">&#125; from &apos;react-native&apos;;</span><br><span class="line"></span><br><span class="line">const instructions = Platform.select(&#123;</span><br><span class="line">    ios: &apos;Press Cmd+R to reload,\n&apos; +</span><br><span class="line">    &apos;Cmd+D or shake for dev menu&apos;,</span><br><span class="line">    android: &apos;Double tap R on your keyboard to reload,\n&apos; +</span><br><span class="line">    &apos;Shake or press menu button for dev menu&apos;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//noinspection BadExpressionStatementJS</span><br><span class="line">type</span><br><span class="line">Props = &#123;&#125;;</span><br><span class="line">//noinspection JSAnnotator</span><br><span class="line">export default class App extends Component&lt;Props&gt; &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">                &lt;Text style=&#123;styles.welcome&#125;&gt;</span><br><span class="line">                    Welcome to React Native!</span><br><span class="line">                &lt;/Text&gt;</span><br><span class="line">                &lt;Text style=&#123;styles.instructions&#125;&gt;</span><br><span class="line">                    To get started, edit App.js</span><br><span class="line">                &lt;/Text&gt;</span><br><span class="line">                &lt;Text style=&#123;styles.instructions&#125;&gt;</span><br><span class="line">                    &#123;instructions&#125;</span><br><span class="line">                &lt;/Text&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const styles = StyleSheet.create(&#123;</span><br><span class="line">    container: &#123;</span><br><span class="line">        flex: 1,</span><br><span class="line">        justifyContent: &apos;center&apos;,</span><br><span class="line">        alignItems: &apos;center&apos;,</span><br><span class="line">        backgroundColor: &apos;#F5FCFF&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    welcome: &#123;</span><br><span class="line">        fontSize: 20,</span><br><span class="line">        textAlign: &apos;center&apos;,</span><br><span class="line">        margin: 10,</span><br><span class="line">    &#125;,</span><br><span class="line">    instructions: &#123;</span><br><span class="line">        textAlign: &apos;center&apos;,</span><br><span class="line">        color: &apos;#333333&apos;,</span><br><span class="line">        marginBottom: 5,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>代码中出现的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">````&lt;Text style=&#123;styles.welcome&#125;&gt;Welcome to React Native!&lt;/Text&gt;```这段代码是JSX语法使用方式，和html标记语言一样，只不过这里引用的是React-Native的组件，Text是一个显示文本的组件，可以看到```style=&#123;styles.welcome&#125;```这是JSX的另一个语法可以将有效的js表示式放入大括号内，Welcome to React Native!为其内容文本.</span><br><span class="line">## 六.组件的属性和状态</span><br><span class="line">在了解了一些基本的JSX和ES6语法后，我们还需要了解两个比较重要的概念即```props```和```state</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 七.组件生命周期</span><br><span class="line">![image](https://upload-images.jianshu.io/upload_images/11716283-7bb3a070d2406452.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/740)</span><br><span class="line"></span><br><span class="line">组件的生命周期会经历三个阶段</span><br></pre></td></tr></table></figure><p>Mounting:挂载<br>Updating:更新<br>Unmounting:移除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对应的生命周期回调方法为</span><br></pre></td></tr></table></figure></p><p>componentWillMount()//组件将要挂载时调用<br>render()//组件渲染时调用<br>componentDidMount()//组件挂载完成时调用<br>componentWillReceiveProps(object nextProps)//组件props和state改变时调用<br>shouldComponentUpdate(object nextProps,object nextState)//返回false不更新组件，一下两个方法不执行<br>componentWillUpdate(object nextProps,object nextState)//组件将要更新时调用<br>componentDidUpdate(object nextProps,object nextState)//组件完成更新时调用<br>componentWillUnmount()//组件销毁时调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里我们需要重点关注的地方在于组件运行的阶段，组件每一次状态收到更新都会调用  ```render()```方法，除非```shouldComponentUpdate```方法返回```false```，可以通过此方法对组件做一些优化避免重复渲染带来的性能消耗。</span><br><span class="line">## 八.样式</span><br><span class="line"></span><br><span class="line">React-Native样式实现了CSS的一个子集，样式的属性与CSS稍有不同，其命名采用驼峰命名，对前端开发者来说基本没差。使用方式也很简单，首先使用StyleSheet创建一个styles</span><br></pre></td></tr></table></figure></p><p>const styles = StyleSheet.create({<br>    container:{<br>        flex:1<br>    }<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后将对应的style传给组件的style属性，例如```&lt;View style=&#123;styles.container&#125;/&gt;</span><br></pre></td></tr></table></figure></p><h2 id="九-常用组件"><a href="#九-常用组件" class="headerlink" title="九.常用组件"></a>九.常用组件</h2><p>在日常开发中最常使用的组件莫过于<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```View```基本上作为容器布局，在里面可以放置各种各样的控件，一般只需要为其设置一个style属性即可，常用的样式属性有flex,width,height,backgroundColor,flexDirector,margin,padding更多可以查看[Layout Props](https://facebook.github.io/react-native/docs/layout-props.html#docsNav)。</span><br><span class="line"></span><br><span class="line">- ```Text```是一个显示文本的控件，只需要在组件的内容区填写文字内容即可，例如```&lt;Text&gt;Hello world&lt;/Text&gt;```,可以为设置字体大小和颜色</span><br><span class="line">```&lt;Text style=&#123;fontSize:14,color:&apos;red&apos;&#125;&gt;Hello world&lt;/Text&gt;```,同时也支持嵌套Text，例如</span><br></pre></td></tr></table></figure></p><p>&lt;Text style={fontWeight: ‘bold’}&gt;<br>        I am bold<br>        &lt;Text style={color: ‘red’}&gt;<br>          and red<br>        <br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- ```TextInput```是文本输入框控件，其使用方式也很简单</span><br></pre></td></tr></table></figure></p><p><textinput style="{width:200,height:50}" onchangetext="{(text)=">console.log(text)}<br>/&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">```style```设置了他的样式，```onChangeText```传入一个方法，该方法会在输入框文字发生变化时调用，这里我们使用```console.log(text)```打印输入框的文字。</span><br><span class="line">- ```Image```是一个图片控件，几乎所有的app都会使用图片作为他们的个性化展示，Image可以加载本地和网络上的图片，当加载网络图片时必须设定控件的大小，否则图片将无法展示</span><br></pre></td></tr></table></figure></textinput></p><p> //加载本地图片,图片地址为相对地址</p><p>&lt;Image style={width:100,height:100} source={require(‘../images/img001.png’)}/&gt;<br>//加载网络图片</p><p>&lt;Image style={width:100,height:100}source={uri:’<a href="https://facebook.github.io/react-native/docs/assets/favicon.png&#39;}/&gt;" target="_blank" rel="noopener">https://facebook.github.io/react-native/docs/assets/favicon.png&#39;}/&gt;</a></p><p><code>`</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要说React Native 入门的一些东西，帮助新手快速入门&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="https://www.jianshu.com/u/3e759a2c717f/categories/React/"/>
    
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Android/"/>
    
      <category term="React Native" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>Android Pie(9.0)适配</title>
    <link href="https://www.jianshu.com/u/3e759a2c717f/2018/07/10/Android%20Pie(9.0)%E9%80%82%E9%85%8D/"/>
    <id>https://www.jianshu.com/u/3e759a2c717f/2018/07/10/Android Pie(9.0)适配/</id>
    <published>2018-07-10T08:07:36.000Z</published>
    <updated>2019-01-24T10:04:44.842Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要说Android Pie(9.0)的适配<br><a id="more"></a></p><h1 id="Android-Pie-9-0-适配"><a href="#Android-Pie-9-0-适配" class="headerlink" title="Android Pie(9.0)适配"></a>Android Pie(9.0)适配</h1><h2 id="查看新功能"><a href="#查看新功能" class="headerlink" title="查看新功能"></a>查看新功能</h2><p>###显示屏缺口支持</p><ul><li>使用<code>getDisplayCutout()</code>函数获取缺口屏（刘海屏）的参数</li><li>可以通过谷歌提供的适配方案，使用挖孔区全屏显示解决：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WindowManager.LayoutParams lp = getWindow().getAttributes();</span><br><span class="line">lp.layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES;</span><br><span class="line">getWindow().setAttributes(lp);</span><br></pre></td></tr></table></figure><p>###多个通知增强功能</p><ul><li>支持图像：现在，Android 9 可在手机的“短信通知”中显示图像。 您可以使用对短信使用 setData()来显示图像。 以下代码段演示了如何创建 Person 和包含图像的短信。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Create new Person.</span><br><span class="line">Person sender = new Person()</span><br><span class="line">        .setName(name)</span><br><span class="line">        .setUri(uri)</span><br><span class="line">        .setIcon(null)</span><br><span class="line">        .build();</span><br><span class="line">// Create image message.</span><br><span class="line">Message message = new Message(&quot;Picture&quot;, time, sender)</span><br><span class="line">        .setData(&quot;image/&quot;, imageUri);</span><br><span class="line">Notification.MessagingStyle style = new Notification.MessagingStyle(getUser())</span><br><span class="line">        .addMessage(&quot;Check this out!&quot;, 0, sender)</span><br><span class="line">        .addMessage(message);</span><br></pre></td></tr></table></figure><p>[图片上传失败…(image-b7321d-1544772143959)]</p><p>###适用于可绘制对象和位图的 ImageDecoder<br>Android 9 引入了 ImageDecoder 类，可提供现代化的图像解码方法。 使用该类取代 BitmapFactory 和 BitmapFactory.Options API。</p><p>###动画<br>Android 9 引入了 AnimatedImageDrawable 类，用于绘制和显示 GIF 和 WebP 动画图像。</p><p>###自动填充框架<br>Android 9 引入了多项改进，自动填充服务可以利用这些改进进一步增强用户填写表单时的体验。 如需详细了解如何在您的应用中使用自动填充功能，请参阅<a href="https://developer.android.google.cn/guide/topics/text/autofill" target="_blank" rel="noopener">自动填充框架</a>指南。</p><p><a href="https://developer.android.google.cn/about/versions/pie/android-9.0#art-aot-dex" target="_blank" rel="noopener"><strong>更多新功能</strong></a></p><p>##行为变更<br>比较多，建议直接看文档</p><p><a href="https://developer.android.google.cn/about/versions/pie/android-9.0-changes-all#privacy-changes-all" target="_blank" rel="noopener">所有应用</a></p><p><a href="https://developer.android.google.cn/about/versions/pie/android-9.0-changes-all#privacy-changes-all" target="_blank" rel="noopener">以 API 级别 28+ 为目标的应用</a></p><p><strong>我们公司的app需要注意的几个点，可能对我们有影响</strong></p><ul><li>限制访问电话号码</li><li>使用非 SDK 接口的限制</li><li>传输层安全协议 (TLS) 实现变更</li><li>Android 9 完全取消了对 Android 安全加密文件 (ASEC) 的支持。</li><li>现在强制执行 FLAG_ACTIVITY_NEW_TASK 要求</li><li>屏幕旋转变更</li><li>构建序列号弃用(在 Android 9 中，Build.SERIAL 始终设置为 “UNKNOWN” 以保护用户的隐私。)</li><li>无法再让多个进程共用同一 WebView 数据目录</li><li>在 Android 9 之前，暂停的应用发出的通知会被取消。 从 Android 9 开始，暂停的应用发出的通知将被隐藏，直至应用继续运行。</li></ul><p>###对于非 SDK 接口的限制<br>无论是直接使用还是通过反射或 JNI 间接使用。 无论应用是引用非 SDK 接口还是尝试使用反射或 JNI 获取其句柄，均适用这些限制。</p><p>下面是名单类型：</p><ul><li>白名单：SDK</li><li>浅灰名单：仍可以访问的非 SDK 函数/字段。</li><li>深灰名单：<ul><li>对于目标 SDK 低于 API 级别 28 的应用，允许使用深灰名单接口。</li><li>对于目标 SDK 为 API 28 或更高级别的应用：行为与黑名单相同</li></ul></li><li>黑名单：受限，无论目标 SDK 如何。 平台将表现为似乎接口并不存在。 例如，无论应用何时尝试使用接口，平台都会引发 NoSuchMethodError/NoSuchFieldException，即使应用想要了解某个特殊类别的字段/函数名单，平台也不会包含接口。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4974296-ef49c349154110d8.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="名单类型"></p><p>下表详细说明了各种访问方式及其相应的结果。</p><p><img src="http://upload-images.jianshu.io/upload_images/4974296-af6d22c4cdd76f47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="名单类型"></p><p><a href="https://www.bilibili.com/video/av29758409" target="_blank" rel="noopener">讲解视频</a></p><p><a href="https://developer.android.google.cn/about/versions/pie/restrictions-non-sdk-interfaces" target="_blank" rel="noopener">veridex检测,需要翻墙</a></p><p>###扩展阅读<br><a href="https://blog.csdn.net/qq_17766199/article/details/81433706" target="_blank" rel="noopener">AndroidX了解一下</a></p><p><a href="https://blog.csdn.net/qq_23062979/article/details/81294551" target="_blank" rel="noopener">Android Jetpack</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要说Android Pie(9.0)的适配&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Android/"/>
    
      <category term="Android 9.0" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Android-9-0/"/>
    
  </entry>
  
  <entry>
    <title>Android 组件化规范</title>
    <link href="https://www.jianshu.com/u/3e759a2c717f/2018/03/19/Android%20%E7%BB%84%E4%BB%B6%E5%8C%96%E8%A7%84%E8%8C%83/"/>
    <id>https://www.jianshu.com/u/3e759a2c717f/2018/03/19/Android 组件化规范/</id>
    <published>2018-03-19T08:07:36.000Z</published>
    <updated>2019-01-24T10:01:54.452Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要说 Android的组件化的一个规范<br><a id="more"></a></p><h1 id="Android-组件化规范"><a href="#Android-组件化规范" class="headerlink" title="Android 组件化规范"></a>Android 组件化规范</h1><h2 id="修订记录"><a href="#修订记录" class="headerlink" title="修订记录"></a>修订记录</h2><table><thead><tr><th>Date</th><th>Author</th><th>Version</th><th>Description</th></tr></thead><tbody><tr><td>2017-11-13</td><td>wuzongbo</td><td>0.0.1</td><td>create</td><td></td></tr><tr><td>2018-03-19</td><td>YasinYao</td><td>0.0.2</td><td>update</td><td></td></tr></tbody></table><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#组件设计">组件设计</a></li><li><a href="#组件使用">组件使用</a></li><li><a href="#组件升级">组件升级</a></li></ul><h2 id="组件设计"><a href="#组件设计" class="headerlink" title="组件设计"></a>组件设计</h2><h3 id="设计要求"><a href="#设计要求" class="headerlink" title="设计要求"></a>设计要求</h3><ul><li>组件必须支持以application方式运行</li><li>每个组件最好能写写支持单元测试</li><li><code>一定要考虑多端通用(APP1、APP2、APP3、……)</code></li></ul><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><ul><li>所有module包名必须为com.xxx.widge.mg{组件名}格式</li><li>所有的资源必须以“{组件名}_{资源名}”命名，防止资源ID冲突，例如mgbutton_activity_home</li></ul><h3 id="组件版本"><a href="#组件版本" class="headerlink" title="组件版本"></a>组件版本</h3><ul><li>每个组件统一使用gradle.properties统一管理版本</li><li>初始版本为：0.0.1，不要以1.0.0开始</li><li>测试版本格式：<code>0.0.1-SNAPSHOT</code>（SNAPSHOT 为快照版本）</li><li>正式版本格式：0.0.1</li></ul><h3 id="组件依赖"><a href="#组件依赖" class="headerlink" title="组件依赖"></a>组件依赖</h3><ul><li>依赖第三方组件，如果不必暴露第三方库，必须使用implementation依赖</li><li><code>禁止组件之间的依赖(很重要！！！)</code>，如果有这种需求那你该考虑设计成interface啦</li></ul><h3 id="build-gradle-实例"><a href="#build-gradle-实例" class="headerlink" title="build.gradle 实例"></a>build.gradle 实例</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.library'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion ANDROID_BUILD_SDK_VERSION <span class="keyword">as</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion ANDROID_BUILD_MIN_SDK_VERSION <span class="keyword">as</span> <span class="keyword">int</span></span><br><span class="line">        targetSdkVersion ANDROID_BUILD_TARGET_SDK_VERSION <span class="keyword">as</span> <span class="keyword">int</span></span><br><span class="line">        <span class="comment">//单个组件版本号，递增</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        <span class="comment">//组件版本名称，不可修改</span></span><br><span class="line">        versionName VERSION</span><br><span class="line">        testInstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//防止资源ID冲突</span></span><br><span class="line">        resourcePrefix project.name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(<span class="string">dir:</span> <span class="string">'libs'</span>, <span class="string">include:</span> [<span class="string">'*.jar'</span>])</span><br><span class="line">    implementation deps.supportAppcompatV7</span><br><span class="line">    testImplementation deps.junit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//maven发布脚本</span></span><br><span class="line">apply <span class="string">from:</span> <span class="string">'../maven.gradle'</span></span><br></pre></td></tr></table></figure><h3 id="组件发布"><a href="#组件发布" class="headerlink" title="组件发布"></a>组件发布</h3><ul><li><a href="Maven.md">配置Maven</a></li><li>单个组件发布命令：./gradlew :{组件名}:uploadArchives</li><li>全部组件发布命令：./gradlew uploadArchives</li></ul><h2 id="组件使用"><a href="#组件使用" class="headerlink" title="组件使用"></a>组件使用</h2><h3 id="组件依赖-1"><a href="#组件依赖-1" class="headerlink" title="组件依赖"></a>组件依赖</h3><ol><li><p>在工程级的build.gradle中增加如下代码</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url <span class="string">'http://192.168.60.96:8082/nexus/content/repositories/android-snapshots/'</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">'http://192.168.60.96:8082/nexus/content/repositories/android/'</span> &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    configurations.all &#123;</span><br><span class="line">        <span class="comment">//每隔10分钟检查动态版本的依赖是否更新</span></span><br><span class="line">        resolutionStrategy.cacheDynamicVersionsFor <span class="number">10</span>, <span class="string">'minutes'</span></span><br><span class="line">        <span class="comment">//每隔24小时检查远程依赖是否存在更新</span></span><br><span class="line">        resolutionStrategy.cacheChangingModulesFor <span class="number">24</span>, <span class="string">'hours'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>依赖开发阶段的组件，版本号必须为快照版本（SNAPSHOT），这样有利于快速发布</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">"com.xxx.widget:mgbanner:0.0.1-SNAPSHOT"</span></span><br></pre></td></tr></table></figure></li><li><p>正式版依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">"com.xxx.widget:mgbanner:0.0.1"</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li><p>如何删除Gradle缓存</p><p>  删除”/Users/wuzongbo/.gradle/caches/modules-2/files-2.1/{package}”目录，再同步Gradle文件（Sync Project with Gradle Files）</p></li><li><p>如何刷新Gradle版本</p><p>  在Android studio中Terminal中输入命令：./gradlew –refresh-dependencies</p></li></ul><h3 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h3><ul><li><p>组件之间使用路由地址跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MogoRouter.getInstance().build(&quot;mogopartner:///home&quot;).open(context);</span><br></pre></td></tr></table></figure></li><li><p>组件内部跳转Builder跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RoomDetailsActivity_Router.intent(getContext()).roomId(123).start();</span><br></pre></td></tr></table></figure></li></ul><h2 id="组件升级"><a href="#组件升级" class="headerlink" title="组件升级"></a>组件升级</h2><p>因为此工程为所有android项目所引用，所以最好能兼容老的版本调用方式就兼容方法与样式</p><h3 id="修改方法"><a href="#修改方法" class="headerlink" title="修改方法"></a>修改方法</h3><p>比如在有一个方法A(int arg1,int arg2),我们要增加一个参数arg3，我们是不能再原来的方法是直接增加<br>必须要新增一个方法A(int arg1,int arg2,int arg3),然后再用这个老的方法去调用新的方法，并且给一个默认值</p><p>修改前<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">a</span><span class="params">(<span class="keyword">int</span> arg1,<span class="keyword">int</span> arg2)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> arg1+arg2;</span><br></pre></td></tr></table></figure></p><p>修改后<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="keyword">int</span> arg1,<span class="keyword">int</span> arg2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a(arg1,arg2,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="keyword">int</span> arg1,<span class="keyword">int</span> arg2,<span class="keyword">int</span> arg3)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg1+arg2+arg3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="修改样式"><a href="#修改样式" class="headerlink" title="修改样式"></a>修改样式</h3><p>比如在有一个组件原来只是伙伴用的，颜色为蓝色， 现在要改为绿色，假设我们把这个颜色做活<br>那么我们做兼容的时候就需要指定一个默认颜色为蓝色，这样就做到兼容伙伴</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要说 Android的组件化的一个规范&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Android/"/>
    
      <category term="组件化" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android 8.0适配</title>
    <link href="https://www.jianshu.com/u/3e759a2c717f/2018/03/10/Android%208.0%E9%80%82%E9%85%8D/"/>
    <id>https://www.jianshu.com/u/3e759a2c717f/2018/03/10/Android 8.0适配/</id>
    <published>2018-03-10T08:07:36.000Z</published>
    <updated>2019-01-24T10:09:25.702Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要说Android 8.0适配<br><a id="more"></a></p><h1 id="Android-8-0适配"><a href="#Android-8-0适配" class="headerlink" title="Android 8.0适配"></a>Android 8.0适配</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>将我们项目中的targetSdkVersion改为 26（8.0） 或者 27（8.1），记住不要超过27，毕竟我还没有告诉你Android P怎么适配（/滑稽）。</p><h2 id="Android-8-0-行为变更"><a href="#Android-8-0-行为变更" class="headerlink" title="Android 8.0 行为变更"></a>Android 8.0 行为变更</h2><h3 id="1-提醒窗口"><a href="#1-提醒窗口" class="headerlink" title="1.提醒窗口"></a>1.提醒窗口</h3><p>如果应用使用 <figure class="highlight plain"><figcaption><span>权限的应用无法再使用以下窗口类型来在其他应用和系统窗口上方显示提醒窗口：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">- TYPE_PHONE</span><br><span class="line">- TYPE_PRIORITY_PHONE</span><br><span class="line">- TYPE_SYSTEM_ALERT</span><br><span class="line">- TYPE_SYSTEM_OVERLAY</span><br><span class="line">- TYPE_SYSTEM_ERROR</span><br></pre></td></tr></table></figure></p><p>相反，应用必须使用名为 <figure class="highlight plain"><figcaption><span>的新窗口类型。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也就是说需要在之前的基础上判断一下：</span><br></pre></td></tr></table></figure></p><p>if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {<br>    mWindowParams.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY<br>}else {<br>    mWindowParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当然记得需要有权限</span><br></pre></td></tr></table></figure></p><p><uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"></uses-permission></p><p><uses-permission android:name="android.permission.SYSTEM_OVERLAY_WINDOW"></uses-permission></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用 ```TYPE_APPLICATION_OVERLAY``` 窗口类型显示应用的提醒窗口时，请记住新窗口类型的以下特性：</span><br></pre></td></tr></table></figure><ul><li>应用的提醒窗口始终显示在状态栏和输入法等关键系统窗口的下面。</li><li>系统可以移动使用 TYPE_APPLICATION_OVERLAY 窗口类型的窗口或调整其大小，以改善屏幕显示效果。</li><li>通过打开通知栏，用户可以访问设置来阻止应用显示使用 TYPE_APPLICATION_OVERLAY 窗口类型显示的提醒窗口。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 2.网页表单自动填充</span><br><span class="line">现在，Android 自动填充框架提供对自动填充功能的内置支持，对于安装到运行 Android 8.0 的设备上的应用，与 WebView 对象相关的下列函数已经发生变化：</span><br></pre></td></tr></table></figure></li></ul><p>WebSettings</p><ul><li>getSaveFormData() 函数现在返回 false。之前，此函数返回 true。</li><li>调用 setSaveFormData() 不再有任何效果。<br>WebViewDatabase</li><li>调用 clearFormData() 不再有任何效果。</li><li>hasFormData() 函数现在返回 false。之前，当表单包含数据时，此函数返回 true。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">### 3.集合的处理</span><br><span class="line">在 Android 8.0 中，Collections.sort() 是在 List.sort() 的基础上实现的。在 Android 7.x（API 级别 24 和 25）中，则恰恰相反。在过去，List.sort() 的默认实现会调用 Collections.sort()。</span><br><span class="line">- List.sort() 的实现不能调用 Collections.sort()，因为这会导致堆栈因无限递归而溢出。相反，如果您需要 List 实现的默认行为，应避免重写 sort()。</span><br><span class="line">此项变更使 Collections.sort() 可以利用优化的 List.sort() 实现，但具有以下限制：</span><br><span class="line">    - 如果父类以不适当的方法实现 sort() ，通常最好使用在 List.toArray()、Arrays.sort() 和 ListIterator.set() 的基础上构建的实现重写 List.sort()。</span><br><span class="line"></span><br><span class="line">    - 如果您选择后者只是因为您希望开发一种适用于所有 API 级别的 sort() 函数，可以考虑赋予其一个唯一的名称，例如 sortCompat()，而不是重写 sort()。</span><br><span class="line">- 现在，Collections.sort() 只是对调用 sort() 的 List 实现进行的一项结构性修改。例如，在 Android 8.0 之前的平台版本中，如果通过调用 List.sort() 进行排序，则当迭代处理 ArrayList 以及在迭代过程中调用 sort() 时，会引发 ConcurrentModificationException。而 Collections.sort() 则不会引发异常。</span><br><span class="line">    此项变更使平台行为更加一致：现在，两种方法都会引发 ConcurrentModificationException。</span><br><span class="line"></span><br><span class="line">现在，```AbstractCollection.removeAll() ```和 ```AbstractCollection.retainAll()``` 始终引发 ```NullPointerException```；之前，当集合为空时不会引发 ```NullPointerException``` 所以我们需要做判空处理。。</span><br><span class="line">### 4.运行时权限</span><br><span class="line">在 Android 8.0 之前，如果应用在运行时请求权限并且被授予该权限，系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用。</span><br><span class="line"></span><br><span class="line">对于针对 Android 8.0 的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而，一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。</span><br><span class="line"></span><br><span class="line">#### 所以总结下来，如果你之前是用什么权限就去申请什么权限，那么恭喜你，这个变化不会影响到你。</span><br><span class="line">#### 如果你只申请了权限组中的某些权限，却用了同组的其他权限，那么你就需要去适配一下了。</span><br><span class="line"></span><br><span class="line">那么怎么适配呢，如果你去检查之前每个申请权限的地方，未免太过麻烦。那么你可以根据你项目中的Manifest文件中需要的权限与权限组去对比，整理出你需要申请的各个权限组,然后申请该权限组</span><br><span class="line">### 5.通知适配</span><br><span class="line">8.0在通知这里变化还挺多的，比如通知渠道、通知标志、通知超时、背景颜色的等，详细的说明可以去看官方的Android 8.0 [功能和 API](https://developer.android.google.cn/guide/topics/ui/notifiers/notifications#ManageChannels)。</span><br><span class="line">#### - 通知渠道：</span><br><span class="line">Android 8.0 引入了通知渠道，其允许您为要显示的每种通知类型创建用户可自定义的渠道。用户界面将通知渠道称之为通知类别。[详见 https://developer.android.com/training/notify-user/channels](https://developer.android.google.cn/training/notify-user/channels ) </span><br><span class="line">![image](http://upload-images.jianshu.io/upload_images/4974296-689527687f761e84.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">可以看到高德地图分的很细致，分为四个组共13个类别(华为貌似对组不生效)。这样有个好处，我们可以控制我们想收到的通知，比如我不喜欢运营活动通知，那我就可以把它关闭。</span><br><span class="line"></span><br><span class="line">这样避免大量的不必要通知，否则使得用户觉得烦，一棒子打死。直接关闭你的允许通知。当然了，大量app都还没有适配，适配的也都分的不是很细致.</span><br><span class="line"></span><br><span class="line">当然更重要的问题是，如果不去适配，可能通知都不会弹出来。那么适配的方法如下：</span><br></pre></td></tr></table></figure><p>private void createNotificationChannel() {<br>    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {</p><pre><code>    NotificationManager notificationManager = (NotificationManager)            getSystemService(Context.NOTIFICATION_SERVICE);    //分组（可选）    //groupId要唯一    String groupId = &quot;group_001&quot;;    NotificationChannelGroup group = new NotificationChannelGroup(groupId, &quot;广告&quot;);    //创建group    notificationManager.createNotificationChannelGroup(group);    //channelId要唯一    String channelId = &quot;channel_001&quot;;    NotificationChannel adChannel = new NotificationChannel(channelId,            &quot;推广信息&quot;, NotificationManager.IMPORTANCE_DEFAULT);    //补充channel的含义（可选）    adChannel.setDescription(&quot;推广信息&quot;);    //将渠道添加进组（先创建组才能添加）    adChannel.setGroup(groupId);    //创建channel    notificationManager.createNotificationChannel(adChannel);    //创建通知时，标记你的渠道id    Notification notification = new Notification.Builder(MainActivity.this, channelId)            .setSmallIcon(R.mipmap.ic_launcher)            .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))            .setContentTitle(&quot;一条新通知&quot;)            .setContentText(&quot;这是一条测试消息&quot;)            .setAutoCancel(true)            .build();    notificationManager.notify(1, notification);}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">效果如下:</span><br><span class="line"></span><br><span class="line">![image](http://upload-images.jianshu.io/upload_images/4974296-247c2245c0bc42f6.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line">华为手机当只有一个渠道时，不会显示，会当做默认通知处理，除非一个以上。</span><br><span class="line"></span><br><span class="line">注意：当Channel已经存在时，后面的createNotificationChannel方法仅能更新其name/description，以及对importance进行降级，其余配置均无法更新。所以如果有必要的修改只能创建新的渠道，删除旧渠道。</span><br><span class="line"></span><br><span class="line">删除渠道代码如下：</span><br></pre></td></tr></table></figure></p><p>private void deleteNotificationChannel(String channelId){<br>    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {<br>        NotificationManager mNotificationManager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);<br>        mNotificationManager.deleteNotificationChannel(channelId);<br>    }<br>}<br><code>`</code></p><h3 id="6-后台限制执行"><a href="#6-后台限制执行" class="headerlink" title="6.后台限制执行"></a>6.后台限制执行</h3><p><a href="https://developer.android.google.cn/about/versions/oreo/background" target="_blank" rel="noopener">具体说明https://developer.android.google.cn/about/versions/oreo/background</a></p><p>应用在两个方面受到限制：</p><p><strong>后台服务限制:</strong> 处于空闲状态时，应用可以使用的后台服务存在限制。 这些限制不适用于前台服务，因为前台服务更容易引起用户注意。</p><p><strong>广播限制：</strong> 除了有限的例外情况，应用无法使用清单注册隐式广播。 它们仍然可以在运行时注册这些广播，并且可以使用清单注册专门针对它们的显式广播。</p><p>在大多数情况下，应用都可以使用 JobScheduler 克服这些限制。 这种方式让应用安排为在未活跃运行时执行工作，不过仍能够使系统可以在不影响用户体验的情况下安排这些作业。</p><p>关于的用法可以参考官方例子：android-JobScheduler<br><a href="https://github.com/googlesamples/android-JobScheduler">https://github.com/googlesamples/android-JobScheduler</a></p><p>当然还有后台位置的限制需要去注意。<br><a href="https://developer.android.google.cn/about/versions/oreo/background-location-limits" target="_blank" rel="noopener">https://developer.android.google.cn/about/versions/oreo/background-location-limits</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p>MIUI 10 通知类别 / Channel 适配</p><p>  <a href="https://dev.mi.com/console/doc/detail?pId=1303" target="_blank" rel="noopener">https://dev.mi.com/console/doc/detail?pId=1303</a></p></li><li>Create and Manage Notification Channels<br>  <a href="https://developer.android.google.cn/training/notify-user/channels" target="_blank" rel="noopener">https://developer.android.google.cn/training/notify-user/channels</a></li><li>Presentation of Notifications<br><a href="https://source.android.google.cn/compatibility/8.0/android-8.0-cdd#3_8_user_interface_compatibility" target="_blank" rel="noopener">https://source.android.google.cn/compatibility/8.0/android-8.0-cdd#3_8_user_interface_compatibility</a></li><li>Android 实现应用更新适配 Android O<br><a href="https://blog.csdn.net/mq2856992713/article/details/79688587" target="_blank" rel="noopener">https://blog.csdn.net/mq2856992713/article/details/79688587</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要说Android 8.0适配&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Android/"/>
    
      <category term="Android 8.0" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Android-8-0/"/>
    
  </entry>
  
  <entry>
    <title>Android多点触控时出现pointerIndex out of range 的错误分析</title>
    <link href="https://www.jianshu.com/u/3e759a2c717f/2018/03/05/Android%E5%A4%9A%E7%82%B9%E8%A7%A6%E6%8E%A7%E6%97%B6%E5%87%BA%E7%8E%B0pointerIndex%20out%20of%20range%20%E7%9A%84%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90/"/>
    <id>https://www.jianshu.com/u/3e759a2c717f/2018/03/05/Android多点触控时出现pointerIndex out of range 的错误分析/</id>
    <published>2018-03-05T08:07:36.000Z</published>
    <updated>2019-01-24T09:44:13.312Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要说Android多点触控时出现pointerIndex out of range 的错误分析<br><a id="more"></a></p><h2 id="Android多点触控时出现pointerIndex-out-of-range-的错误分析"><a href="#Android多点触控时出现pointerIndex-out-of-range-的错误分析" class="headerlink" title="Android多点触控时出现pointerIndex out of range 的错误分析"></a>Android多点触控时出现pointerIndex out of range 的错误分析</h2><h3 id="关于多点触控时出现pointerIndex-out-of-range这个问题在网上查了好多资料，有以下几种情况："><a href="#关于多点触控时出现pointerIndex-out-of-range这个问题在网上查了好多资料，有以下几种情况：" class="headerlink" title="关于多点触控时出现pointerIndex out of range这个问题在网上查了好多资料，有以下几种情况："></a>关于多点触控时出现pointerIndex out of range这个问题在网上查了好多资料，有以下几种情况：</h3><ul><li><h4 id="1-Android自身的问题，需要重新编译代码：这个没有验证过；"><a href="#1-Android自身的问题，需要重新编译代码：这个没有验证过；" class="headerlink" title="1.Android自身的问题，需要重新编译代码：这个没有验证过；"></a>1.Android自身的问题，需要重新编译代码：这个没有验证过；</h4></li><li><h4 id="2-将返回结果改为return-false-：这是一个老外写的解决方法，本来以为能解决问题，结果…-呵呵了，连单点的拖动都不能用了"><a href="#2-将返回结果改为return-false-：这是一个老外写的解决方法，本来以为能解决问题，结果…-呵呵了，连单点的拖动都不能用了" class="headerlink" title="2.将返回结果改为return false; ：这是一个老外写的解决方法，本来以为能解决问题，结果….呵呵了，连单点的拖动都不能用了-.-!!"></a>2.将返回结果改为return false; ：这是一个老外写的解决方法，本来以为能解决问题，结果….呵呵了，连单点的拖动都不能用了-.-!!</h4></li><li><h4 id="3-没有处理异常：IllegalArgumentException"><a href="#3-没有处理异常：IllegalArgumentException" class="headerlink" title="3.没有处理异常：IllegalArgumentException"></a>3.没有处理异常：IllegalArgumentException</h4>这个靠点谱，因为控制台确实也报了这个错误，但一般文章都只贴了try{}catch代码，没写为什么，试了好多次，“一拖动”图片没了！</li></ul><p>下面是具体的报错日志:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">E/CrashReport: java.lang.IllegalArgumentException: pointerIndex out of range</span><br><span class="line">       at android.view.MotionEvent.nativeGetAxisValue(Native Method)</span><br><span class="line">       at android.view.MotionEvent.getX(MotionEvent.java:2080)</span><br><span class="line">       at androidx.viewpager.widget.ViewPager.onInterceptTouchEvent(ViewPager.java:2072)</span><br><span class="line">       at android.view.ViewGroup.dispatchTouchEvent(ViewGroup.java:2120)</span><br></pre></td></tr></table></figure><p>这个问题通过重写viewpager 然后try()catch   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">### 问题分析</span><br><span class="line">##### 这个问题的这个准确的位置是在event.getX(int)和event.getY(int)中会报错，因为你的触控点（那个int参数）可能越界了！我的问题是在两点触控后，有一个手指抬起的时候出现的，发现问题了没有！！！！当两点触控后抬起一个手指的时候只有一个触控点了，通过event.getX(1)的时候就越界了！所以只是try｛｝catch｛｝是可以解决问题,但是没解决根本问题的。 </span><br><span class="line">##### 这个问题的根本在于判断动作的时候可能没有做好case:MotionEvent.ACTION_POINTER_UP这个动作的处理，或没有调用super.onInterceptTouchEvent导致没有对pointerIndex 进行重新赋值。这个动作是在多点触控后，抬起部分手指（还有手指在屏幕上）的时候触发的。</span><br><span class="line"></span><br><span class="line">### 问题解决</span><br><span class="line">#### 1.处理好case:MotionEvent.ACTION_POINTER_UP的操作</span><br><span class="line">#### 2.调用 super.onInterceptTouchEvent();更新poinerIndex状态</span><br><span class="line">#### 3.重写报错的viewGroup 并try&#123;&#125;catch会出错的onIntercepterTouchevent()方法</span><br></pre></td></tr></table></figure></p><p>  @Override<br>    public boolean onInterceptTouchEvent(MotionEvent ev) {<br>        try {<br>            return super.onInterceptTouchEvent(ev);<br>        } catch (IllegalArgumentException ex) {<br>            ex.printStackTrace();<br>        }<br>        return false;<br>    }<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要说Android多点触控时出现pointerIndex out of range 的错误分析&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Android/"/>
    
      <category term="Exception" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>为什么要升级Rxjava2？</title>
    <link href="https://www.jianshu.com/u/3e759a2c717f/2017/12/10/Rxjava2%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    <id>https://www.jianshu.com/u/3e759a2c717f/2017/12/10/Rxjava2技术分享/</id>
    <published>2017-12-10T08:07:36.000Z</published>
    <updated>2019-01-24T09:47:07.315Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要说我们为什么要升级Rxjava2，以及升级Rxjava2的好处<br><a id="more"></a></p><h2 id="1-为什么要升级Rxjava2"><a href="#1-为什么要升级Rxjava2" class="headerlink" title="1. 为什么要升级Rxjava2"></a>1. 为什么要升级Rxjava2</h2><h4 id="1-兼容Reactive-Streams规范-官网"><a href="#1-兼容Reactive-Streams规范-官网" class="headerlink" title="1. 兼容Reactive Streams规范 官网"></a>1. 兼容Reactive Streams规范 <a href="https://github.com/reactive-streams/reactive-streams-jvm">官网</a></h4><pre><code>Reactive Streams 是一种为异步流处理提供非阻塞压力的标准。</code></pre><h4 id="2-更好的处理BackPressure的情况—-Flowable"><a href="#2-更好的处理BackPressure的情况—-Flowable" class="headerlink" title="2. 更好的处理BackPressure的情况— Flowable"></a>2. 更好的处理BackPressure的情况— Flowable</h4><pre><code> 背压，即生产者的速度大于消费者的速度带来的问题使用Flowable我们需要定义它的事件处理策略(缓存,丢弃,报错)</code></pre><h4 id="3-拥有比Rxjava1更好的性能"><a href="#3-拥有比Rxjava1更好的性能" class="headerlink" title="3. 拥有比Rxjava1更好的性能"></a>3. 拥有比Rxjava1更好的<a href="https://github.com/akarnokd/akarnokd-misc/issues/2">性能</a></h4><p><img src="https://cloud.githubusercontent.com/assets/1269832/18634280/93a82d0a-7e80-11e6-9485-5496fc98483f.png" alt="image"></p><h2 id="2-Rxjava1到Rxjava2有哪些变化"><a href="#2-Rxjava1到Rxjava2有哪些变化" class="headerlink" title="2 .Rxjava1到Rxjava2有哪些变化"></a>2 .Rxjava1到Rxjava2有哪些变化</h2><h4 id="1-Nulls"><a href="#1-Nulls" class="headerlink" title="1.Nulls"></a>1.Nulls</h4><pre><code>这是一个很大的变化，熟悉 RxJava 1.x 的童鞋一定都知道，1.x 是允许我们在发射事件的时候传入 null 值的，但现在 2.x 不支持了，直接抛 NullPointerException 。</code></pre><h4 id="2-Observable-gt-Observable-Flowable"><a href="#2-Observable-gt-Observable-Flowable" class="headerlink" title="2. Observable-&gt;Observable,Flowable"></a>2. Observable-&gt;Observable,Flowable</h4><pre><code>1.)基本对比- rxjava1的Observable支持背压 通过.onBackpressureXXX使得支持背压 订阅关系  Observable subscribe Observer(new Acition1)- rxjava2的Observable不支持背压 他的订阅关系Observable-&gt;subscribe -&gt;Observer(new Consumer)- rxjava2 的为了支持背压 订阅关系 Flowable-&gt;subscribe-&gt;Subscriber(new Consumer)2.)发射世界和接收事件满足的条件- 上游可以发送无限个onNext, 下游也可以接收无限个onNext.- 当上游发送了一个onComplete后, 上游onComplete之后的事件将会继续发送, 而下游收到onComplete事件之后将不再继续接收事件.- 当上游发送了一个onError后, 上游onError之后的事件将继续发送, 而下游收到onError事件之后将不再继续接收事件.- 上游可以不发送onComplete或onError.- 最为关键的是onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError, 反之亦然</code></pre><h4 id="3-调度器的变化"><a href="#3-调度器的变化" class="headerlink" title="3.调度器的变化"></a>3.调度器的变化</h4><pre><code>- Schedulers.io() 代表io操作的线程, 通常用于网络,读写文件等io密集型的操作- Schedulers.computation() 代表CPU计算密集型的操作, 例如需要大量计算的操作- Schedulers.newThread() 代表一个常规的新线程- Scheduiers.trampoline() 代表不是立即执行而是加入到队列它是repeat()和retry()的默认调度器- Schedulers.immediate()  代表在当前线程操作(2.X 取消)- AndroidSchedulers.mainThread() 代表Android的主线程</code></pre><h4 id="4-Function相关"><a href="#4-Function相关" class="headerlink" title="4.Function相关"></a>4.Function相关</h4><pre><code>在1.x 中是有 Func1，Func2.....FuncN的，但 2.x 中将它们移除，而采用 Function 替换了 Func1，采用 BiFunction 替换了 Func 2..N。并且，它们都增加了 throws Exception，也就是说，不用担心我们做某些操作还需要 try-catch 了。</code></pre><h4 id="5-观察者的接口实-Observer对比Subscriber"><a href="#5-观察者的接口实-Observer对比Subscriber" class="headerlink" title="5. 观察者的接口实  Observer对比Subscriber"></a>5. 观察者的接口实  Observer对比Subscriber</h4><p> Observer(rx1)   Subscription  CompositeSubscription</p><ul><li>void onNext(Object o)</li><li>void onError(Throwable e)</li><li><p>void onCompleted();</p><p>Subscriber(rx2) Disposable   CompositeDisposable  </p><ul><li>void onSubscribe(Disposable s) </li><li>void onNext(Object o) </li><li>void onError(Throwable t)  </li><li>void onComplete()</li></ul></li></ul><h2 id="3-Rxjava2中一些强大功能和应用场景"><a href="#3-Rxjava2中一些强大功能和应用场景" class="headerlink" title="3.Rxjava2中一些强大功能和应用场景"></a>3.Rxjava2中一些强大功能和应用场景</h2><ul><li>采用 concat 操作符先读取缓存再通过网络请求获取数据<ul><li>利用 concat 的必须调用 onComplete 后才能订阅下一个 Observable 的特性</li></ul></li><li>使用 flatMap 实现多个网络请求依次依赖<ul><li>flatMap 操作符可以将一个发射数据的 Observable 变换为多个 Observables ，然后将它们发射的数据合并后放到一个单独的 Observable</li></ul></li><li>使用 zip 操作符，实现多个接口数据共同更新 UI<ul><li>zip 操作符可以将多个 Observable 的数据结合为一个数据源再发射出去</li></ul></li><li>采用 interval 操作符实现心跳间隔任务<ul><li>interval就是轮训 </li></ul></li><li>使用debounce操作符,实现现需操作放过滤不必要的消息<ul><li>debounce可以指定一段时间内仅第一次发出的消息有效<br>想必即时通讯等需要轮训的任务在如今的 APP 中已是很常见，而 RxJava 2.x 的 interval 操作符可谓完美地解决了我们的疑惑。</li></ul></li><li>retryWhen操作符实现错误重试机制<ul><li>retryWhen可以在错误发生时指定重试次数以及间隔 </li></ul></li></ul><h2 id="4-RxJava1-x-如何平滑升级到RxJava2-x？"><a href="#4-RxJava1-x-如何平滑升级到RxJava2-x？" class="headerlink" title="4.RxJava1.x 如何平滑升级到RxJava2.x？"></a>4.RxJava1.x 如何平滑升级到RxJava2.x？</h2><p>由于RxJava2.x变化较大无法直接升级，幸运的是，官方开发者提供了RxJava2Interop这个库，可以方便地将RxJava1.x升级到RxJava2.x，或者将RxJava2.x转回RxJava1.x。地址：<a href="https://github.com/akarnokd/RxJava2Interop">https://github.com/akarnokd/RxJava2Interop</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要说我们为什么要升级Rxjava2，以及升级Rxjava2的好处&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Android/"/>
    
      <category term="Rxjava" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Rxjava/"/>
    
  </entry>
  
  <entry>
    <title>View 的事件体系</title>
    <link href="https://www.jianshu.com/u/3e759a2c717f/2017/11/17/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"/>
    <id>https://www.jianshu.com/u/3e759a2c717f/2017/11/17/View的事件体系/</id>
    <published>2017-11-17T05:07:36.000Z</published>
    <updated>2019-01-24T09:37:23.901Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要说View的基础知识，View的滑动和View分发机制<br><a id="more"></a></p><h2 id="View-的事件体系"><a href="#View-的事件体系" class="headerlink" title="View 的事件体系"></a>View 的事件体系</h2><h3 id="1-View的基础知识"><a href="#1-View的基础知识" class="headerlink" title="1.View的基础知识"></a>1.View的基础知识</h3><ul><li>View是所有控件的基类</li><li>View由四个顶点决定,top,left,right,bottom</li><li>x,y View左上角的坐标 </li><li>translationX,translationY是View左上角相对于父容器的偏移量默认是0</li><li>x = left + translationX</li><li>y = top + translationY</li><li><p>MotionEvent  在手指接触屏幕后所产生的一系列事件中 典型的事件有如下几种:</p><ul><li>ACTION_DOWN—手指刚接触屏幕;</li><li>ACTION_MOVE—手指在屏幕上移动;</li><li><p>ACTION_UP—手机从屏幕上松开的一瞬间.</p><p>通过MotionEvent对象我们可以得到点击事件发生的x和y坐标</p></li><li><p>getX/getY返回的是相对于当前View左上角的x和y坐标</p></li><li>getRawX/getRawY 返回的是相对于屏幕左上角的x和y坐标</li></ul></li><li><p>TouchSlop</p><ul><li>系统能识别的被认为是滑动的最小距离.</li><li>获取这个常量:ViewConfiguration.get(getContext()).getScaledTouchSlop().</li></ul></li><li><p>VelocityTracker</p><ul><li>速度追踪,用于追踪手指在滑动过程中的速度,包括水平和竖直速度.</li><li>VelocityTracker vt = VelocityTracker.obtain();</li><li>vt.addMovement(event);</li><li>vt.computeCurrentVelocity(1000);</li><li>int xV= (int)vt.getXVelocity();</li><li>int yV = (int)vt.getYVelcity();</li><li>vt.clear();</li><li>vt.recycle();</li></ul></li><li>GestureDetector<ul><li>手势检测,用于辅助检测用户的单击,滑动,长按,双击等行为.<h3 id="2-View的滑动"><a href="#2-View的滑动" class="headerlink" title="2. View的滑动"></a>2. View的滑动</h3>View滑动的常见实现方式</li></ul></li><li>通过View本身提供的scrollTo/scrollBy方法</li><li>通过动画给View施加平移效果来实现滑动</li><li>通过改变View的LayoutParams 是的View重新布局而实现滑动</li><li></li></ul><h3 id="3-View分发机制"><a href="#3-View分发机制" class="headerlink" title="3.View分发机制"></a>3.View分发机制</h3><p> 实质上就是MotionEvent的事件分发机制。即当MotionEvent产生一个事件以后，系统需要把事件传递给一个具体的View的这样一个过程。他主要包括三个方法：dispatchTouchEvent onInterceptTouchEvent onTouchEvent.</p><h4 id="public-boolean-dispatchTouchEvent-MotionEvent-e"><a href="#public-boolean-dispatchTouchEvent-MotionEvent-e" class="headerlink" title="- public boolean dispatchTouchEvent(MotionEvent e)"></a>- public boolean dispatchTouchEvent(MotionEvent e)</h4><p>用来进行事件 经过该View的事件，一定会调用这个方法。返回结果受onIntercepterTouchEvent 和onTouchEvent影响。返回值表示是否消费事件。</p><h4 id="public-boolean-onInterceptTouchEvent-MotionEvent-e"><a href="#public-boolean-onInterceptTouchEvent-MotionEvent-e" class="headerlink" title="- public boolean onInterceptTouchEvent(MotionEvent e)"></a>- public boolean onInterceptTouchEvent(MotionEvent e)</h4><p>在上述方法内部，判断是否拦截事件 同一个事件只会运行一次 返回结果表示是否拦截事件 </p><h4 id="public-boolean-onTouchEvent-MotionEvent-e"><a href="#public-boolean-onTouchEvent-MotionEvent-e" class="headerlink" title="- public boolean onTouchEvent(MotionEvent e)"></a>- public boolean onTouchEvent(MotionEvent e)</h4><p>在diapatchTouchEvent方法内部 用来处理点击事件 表示是否消耗该事件  同一事件序列只会执行一次</p><h4 id="ViewGroup事件分发过程："><a href="#ViewGroup事件分发过程：" class="headerlink" title="ViewGroup事件分发过程："></a>ViewGroup事件分发过程：</h4><p>对于一个Viewgroup来说，接收到事件以后首先会调用diapatchTouchEvent 如果返回值是true 也就是说onInterceptTouchEvent返回true则表示自己消费这个事件 那么就会调用onTouchEvent方法；如果onIntercepterTouchEvent返回值是false，表示自己不处理该事件通过child.dispatchTouchEvent发送事件给子布局，如此反复 知道最后被处理。</p><h4 id="View的事件优先级"><a href="#View的事件优先级" class="headerlink" title="View的事件优先级"></a>View的事件优先级</h4><p>当一个View设置了OnTouchListener以后 事件会先执行OnTouchListener的onTouch方法，如果onTouch返回为true 表示OntouchListener消费了事件 就不会传递到OntouchEvent；如果返回为false，才会传递到OntouchEvent，如果OntouchEvent返回为true，这OntouchEvent消费事件，后续额onClicklister就不会接收到事件，click方法就不会被调用；如果OntouchEvent返回为false 才会执行到click方法。 所以view的监听优先级 OnTouchListener &gt; OnTouchEvent &gt; OnClickListener</p><p>事件分发方法的执行顺序 dispatchTouchEvent-&gt;onIntercepteTouchEvent-&gt;OnTouchListener(onTouch)-&gt;onTouchEvent-&gt;onClickListener(click)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要说View的基础知识，View的滑动和View分发机制&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Android/"/>
    
      <category term="View" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>应用开发进阶必经之路之性能优化</title>
    <link href="https://www.jianshu.com/u/3e759a2c717f/2017/10/17/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6%E5%BF%85%E7%BB%8F%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://www.jianshu.com/u/3e759a2c717f/2017/10/17/应用开发进阶必经之路之性能优化/</id>
    <published>2017-10-17T08:00:36.000Z</published>
    <updated>2019-01-24T09:39:13.381Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要说Android应用开发中的一些性能优化点，帮助你更好的做好APP的性能优化<br><a id="more"></a></p><h1 id="性能问题分类"><a href="#性能问题分类" class="headerlink" title="性能问题分类"></a>性能问题分类</h1><h3 id="1-内存问题："><a href="#1-内存问题：" class="headerlink" title="- 1.内存问题："></a>- 1.内存问题：</h3><p> 耗内存、OOM、程序切换到后台后占用内存无法释放（OOM会影响产品的稳定性；耗内存、内存泄露会影响整机的性能；占用内存多预示着留给其它应用的剩余内存空间小）；</p><h3 id="2-功耗问题"><a href="#2-功耗问题" class="headerlink" title="- 2.功耗问题"></a>- 2.功耗问题</h3><p> 发烫（耗电）</p><h3 id="3-流畅度问题"><a href="#3-流畅度问题" class="headerlink" title="- 3.流畅度问题"></a>- 3.流畅度问题</h3><p> 启动慢、页面显示需要长时间转圈加载、页面切换卡顿、黑白屏（卡慢崩会让人烦躁）；</p><p> 针对上面一系列的性能问题，谷歌官方提供了各种各样的工具来针对性的解决各个方面的问题，也有很多不错的第三方工具值得尝试：<br>内存问题：提供了Android Studio的静态代码检测功能、Android Monitor；第三方内存泄露分析工具Leakcanary、MAT；<br>功耗问题：提供了GPU呈现模式、battery-historian、Android Monitor；</p><h2 id="流畅度问题：提供了Android-Studio的静态代码检测功能、Android-Monitor、HierarchyViewer、StrictMode、过渡绘制检测工具、TraceView等；"><a href="#流畅度问题：提供了Android-Studio的静态代码检测功能、Android-Monitor、HierarchyViewer、StrictMode、过渡绘制检测工具、TraceView等；" class="headerlink" title="流畅度问题：提供了Android Studio的静态代码检测功能、Android Monitor、HierarchyViewer、StrictMode、过渡绘制检测工具、TraceView等；"></a>流畅度问题：提供了Android Studio的静态代码检测功能、Android Monitor、HierarchyViewer、StrictMode、过渡绘制检测工具、TraceView等；</h2><h2 id="流畅度问题"><a href="#流畅度问题" class="headerlink" title="流畅度问题"></a>流畅度问题</h2><p> 主要是界面过度绘制问题<br> 优化方法</p><ul><li><p>merge<br>作为根目录减少层级 原理是减少根目录Framlayout的绘制</p><ul><li>viewStub<br>加载页面时不绘制该布局<br>原理是重写onDraw方法并被置空，onMeasure方法也没有实现 从而不绘制 而是在需要显示的时候显示（inflate）</li><li>Space<br>加载页面时不绘制布局<br>原理同viewStub类似 但是他是绘制尺寸大小的 有自己的宽高</li><li>去掉多余的背景<br>一般的activity都有个主题 它会为activity的window设置背景，再为activity设置背景显然会多绘制一次<br>原理是减少一层背景的绘制</li></ul><p>==说明==：<br>  1、在主题中去掉Window的背景时要注意，去掉之后必须重新运行程序检查一下，避免有些Activity并没有设置背景导致界面背景为黑色；<br>  2、有的程序为了避免冷启动时界面黑屏/白屏的问题，在主题中为window设置了一张图片，然后在布局文件中为Activity也设置了背景，这样既会导致过渡绘制问题，还会导致内存问题（同一个页面两张全屏的图片，双倍内存）；所以这种解决方式并不妥，如果是启动速度问题，直接优化启动速度比这种方式靠谱。</p></li><li>最重要的是产品设计合理，多和产品、UI沟通，避免无意义的工作</li></ul><hr><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>工具：<br>Android Studio提高代码质量必杀技：Inspact Code  LeakCanery</p><h4 id="非静态内部类导致的内存泄漏："><a href="#非静态内部类导致的内存泄漏：" class="headerlink" title="- 非静态内部类导致的内存泄漏："></a>- 非静态内部类导致的内存泄漏：</h4><p> 比如Handler，解决方法是将内部类写成静态内部类，在静态内部类中使用软引用/弱引用持有外部类的实例</p><h4 id="IO操作后，没有关闭文件导致的内存泄露"><a href="#IO操作后，没有关闭文件导致的内存泄露" class="headerlink" title="-IO操作后，没有关闭文件导致的内存泄露"></a>-IO操作后，没有关闭文件导致的内存泄露</h4><p> 比如Cursor、FileInputStream、FileOutputStream使用完后没有关闭，这种问题在Android Studio 2.0中能够通过静态代码分析检查出来，直接改善就可以了；</p><h4 id="自定义View中使用TypedArray后，没有recycle，"><a href="#自定义View中使用TypedArray后，没有recycle，" class="headerlink" title="-自定义View中使用TypedArray后，没有recycle，"></a>-自定义View中使用TypedArray后，没有recycle，</h4><p> 这种问题也可以在Android Studio 2.0中能够通过静态代码分析检查出来，直接改善就可以了；</p><h4 id="某些地方使用了四大组件的context，在离开这些组件后仍然持有其context导致的内存泄露"><a href="#某些地方使用了四大组件的context，在离开这些组件后仍然持有其context导致的内存泄露" class="headerlink" title="-某些地方使用了四大组件的context，在离开这些组件后仍然持有其context导致的内存泄露"></a>-某些地方使用了四大组件的context，在离开这些组件后仍然持有其context导致的内存泄露</h4><p> 1、数字1：启动Activity在这些类中是可以的，但是需要创建一个新的task，一般情况不推荐；</p><h4 id="属性动画导致的内存泄漏"><a href="#属性动画导致的内存泄漏" class="headerlink" title="属性动画导致的内存泄漏"></a>属性动画导致的内存泄漏</h4><p> google提供的一种无限循环的属性动画 在activity销毁是 需要先将动画关闭</p><p>2、数字2：在这些类中去layout inflate是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用；</p><p>3、数字3：在Receiver为null时允许，在4.2或以上的版本中，用于获取黏性广播的当前值。（可以无视）；</p><h4 id="加载图片导致的内存问题"><a href="#加载图片导致的内存问题" class="headerlink" title="加载图片导致的内存问题"></a>加载图片导致的内存问题</h4><p> 这个问题遵循以下原则就可以了：<br>1、UI只提供一套高分辨率的图，图片建议放在drawable-xxhdpi文件夹下（放在xxxhdpi或者更高分辨率的文件夹下没有必要，权衡利弊，照顾主流设备即可），这样在低分辨率设备中图片的大小只是压缩，不会存在内存增大的情况；<br>2、涉及到桌面插件或者不需要缩放的图片，放在drawable-nodpi文件夹下，这个文件夹下的图片在任何设备上都是不会缩放的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要说Android应用开发中的一些性能优化点，帮助你更好的做好APP的性能优化&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Android/"/>
    
      <category term="性能优化" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>HashMap的实现原理</title>
    <link href="https://www.jianshu.com/u/3e759a2c717f/2017/09/10/HashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://www.jianshu.com/u/3e759a2c717f/2017/09/10/HashMap的实现原理/</id>
    <published>2017-09-10T08:07:36.000Z</published>
    <updated>2019-01-24T09:40:27.917Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br><a id="more"></a></p><h1 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h1><h4 id="1-HashMap概述"><a href="#1-HashMap概述" class="headerlink" title="1.HashMap概述"></a>1.HashMap概述</h4><p>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><hr><h4 id="2-HashMap的数据结构"><a href="#2-HashMap的数据结构" class="headerlink" title="2.HashMap的数据结构"></a>2.HashMap的数据结构</h4><p>在 Java 编程语言中，最基本的结构就是两种，一个是数组，另外一个是指针（引用），HashMap 就是通过这两个数据结构进行实现。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。<br><img src="http://pic002.cnblogs.com/images/2012/80896/2012060316385671.jpg" alt="image"></p><p>每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢? 一般情况是通过hash(key)%len获得，也就是元素的key的哈希值对数组长度取模得到。比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。</p><p>　　HashMap其实也是一个线性的数组实现的,所以可以理解为其存储数据的容器就是一个线性数组。这可能让我们很不解，一个线性的数组怎么实现按键值对来存取数据呢？这里HashMap有做一些处理。</p><p>　　首先HashMap里面实现一个静态内部类Entry，其重要的属性有 key , value, next，从属性key,value我们就能很明显的看出来Entry就是HashMap键值对实现的一个基础bean，我们上面说到HashMap的基础就是一个线性数组，这个数组就是Entry[]，Map里面的内容都保存在Entry[]里面。</p><h2 id=""><a href="#" class="headerlink" title="　　"></a>　　</h2><h4 id="3-HashMap的初始化过程"><a href="#3-HashMap的初始化过程" class="headerlink" title="3. HashMap的初始化过程"></a>3. HashMap的初始化过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　    public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">    this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1,</span><br><span class="line">                  DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">    inflateTable(threshold);</span><br><span class="line"></span><br><span class="line">    putAllForCreate(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DEFAULT_LOAD_FACTOR :</strong>  负载因子的默认值0.75  表示数据填充的临界值,即数据达到总数据的75%时就开始准备扩容了.</p><p><strong>DEFAULT_INITIAL_CAPACITY :</strong> 默认传入Map中的数据默认值为4<br>从上面看出 现实调用自己的构造方法,然后创建存储的Table(实际是数组),最后把值添加到创建的table中</p><ul><li><h5 id="this-var1-var2-实际调用的构造方法"><a href="#this-var1-var2-实际调用的构造方法" class="headerlink" title="this(var1,var2)实际调用的构造方法"></a>this(var1,var2)实际调用的构造方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span><br><span class="line"> * capacity and load factor.</span><br><span class="line"> *</span><br><span class="line"> * @param  initialCapacity the initial capacity</span><br><span class="line"> * @param  loadFactor      the load factor</span><br><span class="line"> * @throws IllegalArgumentException if the initial capacity is negative</span><br><span class="line"> *         or the load factor is nonpositive</span><br><span class="line"> */</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    &#125; else if (initialCapacity &lt; DEFAULT_INITIAL_CAPACITY) &#123;</span><br><span class="line">        initialCapacity = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>initialCapacity :</strong> ==即初始化申请空间的值,不等于Map实际初始化的内部数组的长度(稍后解释为什么)==,若不填写默认是DEFAULT_INITIAL_CAPACITY也就是4<br>initialCapacity的最大值为1 &lt;&lt; 30 也就是2^30次方<br>initialCapacity的最小值为DEFAULT_INITIAL_CAPACITY也就是4</p><p><strong>loadFactor :</strong> 负载因子的初始化值,若不填写默认为DEFAULT_LOAD_FACTOR也就是0.75</p><p><strong>threshold :</strong> 下次扩容时的申请空间值</p><ul><li><h5 id="inflateTable方法"><a href="#inflateTable方法" class="headerlink" title="inflateTable方法"></a>inflateTable方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Inflates the table.</span><br><span class="line"> */</span><br><span class="line">private void inflateTable(int toSize) &#123;</span><br><span class="line">    // Find a power of 2 &gt;= toSize</span><br><span class="line">    int capacity = roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">    // Android-changed: Replace usage of Math.min() here because this method is</span><br><span class="line">    // called from the &lt;clinit&gt; of runtime, at which point the native libraries</span><br><span class="line">    // needed by Float.* might not be loaded.</span><br><span class="line">    float thresholdFloat = capacity * loadFactor;</span><br><span class="line">    if (thresholdFloat &gt; MAXIMUM_CAPACITY + 1) &#123;</span><br><span class="line">        thresholdFloat = MAXIMUM_CAPACITY + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threshold = (int) thresholdFloat;</span><br><span class="line">    table = new HashMapEntry[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="这里面有个重点"><a href="#这里面有个重点" class="headerlink" title="这里面有个重点"></a>这里面有个重点</h6><p> 实际申请的内部数组的大小 int capacity = roundUpToPowerOf2(toSize);</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    private static int roundUpToPowerOf2(int number) &#123;</span><br><span class="line">    // assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span><br><span class="line">    int rounded = number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">            ? MAXIMUM_CAPACITY</span><br><span class="line">            : (rounded = Integer.highestOneBit(number)) != 0</span><br><span class="line">                ? (Integer.bitCount(number) &gt; 1) ? rounded &lt;&lt; 1 : rounded</span><br><span class="line">                : 1;</span><br><span class="line"></span><br><span class="line">    return rounded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这段代码在传入的number在正常数值都会走 Integer.highestOneBit(number)和Integer.bitCount(number)<br>    里面的代码都是位运算 ==roundUpToPowerOf2这个方法实际上的功能就是返回一个最小的是2^n且它大于等于number的值==</p><p> 例如 number= 4 那么roundUpToPowerOf2的返回值就是2^2 = 4</p><p> number = 5 那么roundUpToPowerOf2的返回值就是2^3 = 8</p><h5 id="那么问题来了-为啥内部数组大小为啥是2-n呢"><a href="#那么问题来了-为啥内部数组大小为啥是2-n呢" class="headerlink" title="那么问题来了  为啥内部数组大小为啥是2^n呢?"></a>那么问题来了  为啥内部数组大小为啥是2^n呢?</h5><p>而当数组长度为16时，即为2的n次方时，2n-1得到的二进制数的每个位上的值都为1（比如(24-1)2=1111），这使得在低位上&amp;时，得到的和原hash的低位相同，加之hash(int h)方法对key的hashCode的进一步优化，加入了高位计算，就使得只有相同的hash值的两个值才会被放到数组中的同一个位置上形成链表。</p><p>　所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p><ul><li><h5 id="putAllForCreate方法"><a href="#putAllForCreate方法" class="headerlink" title="putAllForCreate方法"></a>putAllForCreate方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void putAllForCreate(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">    for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">        putForCreate(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这里是个foreach循环,将m中的数据拿出来一一添加到map, 下面看具体的putForCreate方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * This method is used instead of put by constructors and</span><br><span class="line"> * pseudoconstructors (clone, readObject).  It does not resize the table,</span><br><span class="line"> * check for comodification, etc.  It calls createEntry rather than</span><br><span class="line"> * addEntry.</span><br><span class="line"> */</span><br><span class="line">private void putForCreate(K key, V value) &#123;</span><br><span class="line">    int hash = null == key ? 0 : sun.misc.Hashing.singleWordWangJenkinsHash(key);</span><br><span class="line">    int i = indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Look for preexisting entry for key.  This will never happen for</span><br><span class="line">     * clone or deserialize.  It will only happen for construction if the</span><br><span class="line">     * input Map is a sorted map whose ordering is inconsistent w/ equals.</span><br><span class="line">     */</span><br><span class="line">    for (HashMapEntry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="1-计算key的hash值"><a href="#1-计算key的hash值" class="headerlink" title="1.计算key的hash值"></a>1.计算key的hash值</h6><p>key==null  -&gt;   hash=0 </p><p>key!=null -&gt; hash = hash(key)</p><h6 id="2-计算数组下标-根据hash值求余-即余数相同的hash值放到相同的数组下标对应的一个链表上-按位取并，作用上相当于取模mod或者取余-。这意味着数组下标相同，并不表示hashCode相同。"><a href="#2-计算数组下标-根据hash值求余-即余数相同的hash值放到相同的数组下标对应的一个链表上-按位取并，作用上相当于取模mod或者取余-。这意味着数组下标相同，并不表示hashCode相同。" class="headerlink" title="2.计算数组下标(根据hash值求余,即余数相同的hash值放到相同的数组下标对应的一个链表上)按位取并，作用上相当于取模mod或者取余%。这意味着数组下标相同，并不表示hashCode相同。"></a>2.计算数组下标(根据hash值求余,即余数相同的hash值放到相同的数组下标对应的一个链表上)按位取并，作用上相当于取模mod或者取余%。这意味着数组下标相同，并不表示hashCode相同。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns index for hash code h.</span><br><span class="line"> */</span><br><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-在对应的key上赋值或者添加一组map"><a href="#3-在对应的key上赋值或者添加一组map" class="headerlink" title="3.在对应的key上赋值或者添加一组map"></a>3.在对应的key上赋值或者添加一组map</h6><hr><h4 id="4-HashMap的存取实现"><a href="#4-HashMap的存取实现" class="headerlink" title="4.HashMap的存取实现"></a>4.HashMap的存取实现</h4><p>HashMap的基本存取过程基本如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 存储时:</span><br><span class="line">int hash = key.hashCode(); // 这个hashCode方法这里不详述,只要理解每个key的hash是一个固定的int值</span><br><span class="line">int index = hash % Entry[].length;</span><br><span class="line">Entry[index] = value;</span><br><span class="line"></span><br><span class="line">// 取值时:</span><br><span class="line">int hash = key.hashCode();</span><br><span class="line">int index = hash % Entry[].length;</span><br><span class="line">return Entry[index];</span><br></pre></td></tr></table></figure></p><ul><li><h5 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    if (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    if (key == null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">    int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key);</span><br><span class="line">    int i = indexFor(hash, table.length);</span><br><span class="line">    for (HashMapEntry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>从上面的源代码中可以看出：<br>1.Map支持key=null<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private V putForNullKey(V value) &#123;</span><br><span class="line">    for (HashMapEntry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;</span><br><span class="line">        if (e.key == null) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(0, null, value, 0);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的代码中可以看到当key==null 会将值放到table[0]索引下,并且当数据重复时,新数据会覆盖原数据,并返回原数据,若不重复则添加到table hash=0,bucketIndex=0;</p><p>2.当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</p><p>addEntry方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    // 获取指定 bucketIndex 索引处的 Entry </span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    // 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry</span><br><span class="line">    table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); //参数e, 是Entry.next</span><br><span class="line">    // 如果 Map 中的 key-value 对的数量超过了极限</span><br><span class="line">    if (size++ &gt;= threshold)</span><br><span class="line">    // 把 table 对象的长度扩充到原来的2倍。</span><br><span class="line">            resize(2 * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>储HashMap中的key-value对时，完全没有考虑Entry中的value，仅仅只是根据key来计算并决定每个Entry的存储位置。我们完全可以把 Map 集合中的 value 当成 key 的附属，当系统决定了 key 的存储位置之后，value 随之保存在那里即可。</p><p>　　hash(int h)方法根据key的hashCode重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的hash冲突。</p><p>   当然HashMap里面也包含一些优化方面的实现，这里也说一下。比如：Entry[]的长度一定后，随着map里面数据的越来越长，这样同一个index的链就会很长，会不会影响性能？HashMap里面设置一个因子(loadFactor)，随着map的size越来越大，Entry[]会以一定的规则加长长度。</p><ul><li><h4 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   public V get(Object key) &#123;</span><br><span class="line">    if (key == null)</span><br><span class="line">        return getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    return null == entry ? null : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当key=null 直接取table的索引为0下的值;<br>当key!=null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">    if (size == 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int hash = (key == null) ? 0 : sun.misc.Hashing.singleWordWangJenkinsHash(key);</span><br><span class="line">    for (HashMapEntry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != null;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return e;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从HashMap中get元素时，首先计算key的hashCode，在通过indexFor方法找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。</p><p>归纳起来简单地说，HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。</p></li></ul><hr><h3 id="5-HashMap的扩容"><a href="#5-HashMap的扩容" class="headerlink" title="5.HashMap的扩容"></a>5.HashMap的扩容</h3><p>  当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</p><p>  那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">     void resize(int newCapacity) &#123;</span><br><span class="line">       HashMapEntry[] oldTable = table;</span><br><span class="line">       int oldCapacity = oldTable.length;</span><br><span class="line">        //如果当前的数组长度已经达到最大值，则不在进行调整</span><br><span class="line">       if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">//根据传入参数的长度定义新的数组</span><br><span class="line">       HashMapEntry[] newTable = new HashMapEntry[newCapacity];</span><br><span class="line">       //按照新的规则，将旧数组中的元素转移到新数组中</span><br><span class="line">       transfer(newTable);</span><br><span class="line">       table = newTable;</span><br><span class="line">         //更新临界值</span><br><span class="line">       threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>  旧数组的数据转到新数组<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  void transfer(HashMapEntry[] newTable) &#123;</span><br><span class="line">    int newCapacity = newTable.length;</span><br><span class="line">    for (HashMapEntry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        while(null != e) &#123;</span><br><span class="line">            HashMapEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            int i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="6-Fail-Fast机制："><a href="#6-Fail-Fast机制：" class="headerlink" title="6.Fail-Fast机制："></a>6.Fail-Fast机制：</h3><p> 我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。</p><p>　　这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。<br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashIterator() &#123;</span><br><span class="line">           expectedModCount = modCount;</span><br><span class="line">           if (size &gt; 0) &#123; // advance to first entry</span><br><span class="line">               HashMapEntry[] t = table;</span><br><span class="line">               while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)</span><br><span class="line">                   ;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p>　　<br>在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map：</p><p>　　　注意到modCount声明为volatile，保证线程之间修改的可见性。（volatile之所以线程安全是因为被volatile修饰的变量不保存缓存，直接在内存中修改，因此能够保证线程之间修改的可见性）　　　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">　        final Entry&lt;K,V&gt; nextEntry() &#123;</span><br><span class="line">    if (modCount != expectedModCount)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    HashMapEntry&lt;K,V&gt; e = next;</span><br><span class="line">    if (e == null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line"></span><br><span class="line">    if ((next = e.next) == null) &#123;</span><br><span class="line">        HashMapEntry[] t = table;</span><br><span class="line">        while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line">    current = e;</span><br><span class="line">    return e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　　<br>　　　在HashMap的API中指出：</p><p>　　由所有HashMap类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不保证在将来不确定的时间发生任意不确定行为的风险。</p><p>　　注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误.</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ul><li>第一、使用线程安全的ConcurrentHashMap或HashTable,它就不会产生ConcurrentModificationException异常，也就是它使用迭代器完全不会产生fail-fast机制</li><li>第二.Collections.synchronizedMap将HashMap包装起来</li></ul><p>返回由指定映射支持的同步（线程安全的）映射。为了保证按顺序访问，必须通过返回的映射完成对底层映射的所有访问。在返回的映射或其任意 collection 视图上进行迭代时，强制用户手工在返回的映射上进行同步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map m = Collections.synchronizedMap(new HashMap());</span><br><span class="line">...</span><br><span class="line">Set s = m.keySet();  //不需要加锁</span><br><span class="line">...</span><br><span class="line">synchronized(m) &#123;  // 对Map的对象m加锁</span><br><span class="line">Iterator i = s.iterator(); // 必须加锁的模块</span><br><span class="line">    while (i.hasNext())</span><br><span class="line">        foo(i.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p> <a href="http://www.cnblogs.com/esther-qing/p/6480768.html" target="_blank" rel="noopener">深入Java集合学习系列：HashMap的实现原理</a></p><p> <a href="http://blog.csdn.net/vking_wang/article/details/14166593" target="_blank" rel="noopener">HashMap实现原理分析</a></p><p> <a href="http://www.cnblogs.com/NewMan13/p/6034140.html" target="_blank" rel="noopener">HashMap, HashTable, CurrentHashMap的区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://www.jianshu.com/u/3e759a2c717f/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Java/"/>
    
      <category term="Hashmap" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Hashmap/"/>
    
  </entry>
  
  <entry>
    <title>升级Android Studio3.0 beta1问题汇总</title>
    <link href="https://www.jianshu.com/u/3e759a2c717f/2017/09/01/%E5%8D%87%E7%BA%A7Android%20Studio3.0%20beta1%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>https://www.jianshu.com/u/3e759a2c717f/2017/09/01/升级Android Studio3.0 beta1问题汇总/</id>
    <published>2017-09-01T08:07:36.000Z</published>
    <updated>2019-01-24T09:42:12.140Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要说升级Android Studio3.0 的几个问题及解决方法<br><a id="more"></a></p><h3 id="1-Gradle-sync-failed-Cause-java-lang-NullPointerException"><a href="#1-Gradle-sync-failed-Cause-java-lang-NullPointerException" class="headerlink" title="1.Gradle sync failed: Cause: java.lang.NullPointerException"></a>1.Gradle sync failed: Cause: java.lang.NullPointerException</h3><p><strong>问题描述:</strong> 这是从AS3.0 alpha版本升级到beta产生的问题<br>官方文档有说明地址<a href="https://androidstudio.googleblog.com/2017/08/android-studio-30-beta-1.html" target="_blank" rel="noopener">https://androidstudio.googleblog.com/2017/08/android-studio-30-beta-1.html</a><br><strong>解决办法:</strong>  菜单栏上 Build &gt; Clean Project  然后重新使用Sync Project 即可</p><h3 id="2-Gradle-sync-failed-Cause-com-android-support-multidex-1-0-2"><a href="#2-Gradle-sync-failed-Cause-com-android-support-multidex-1-0-2" class="headerlink" title="2.Gradle sync failed: Cause: com.android.support:multidex:1.0.2"></a>2.Gradle sync failed: Cause: com.android.support:multidex:1.0.2</h3><p><strong>问题描述:</strong> 这个也是升级beta1出现的  他提示我升级到multidex的1.0.2版本  然后我升级到1.0.2版本以后发现找不到资源(下载不下来)<br><strong>解决办法:</strong><br>在项目的根目录build.gradle中加入配置google()仓库,jcenter仓库中没有最新的1.0.2版本的multidex<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()//新增的</span><br><span class="line">        jcenter()</span><br><span class="line">        mavenCentral()</span><br><span class="line">        maven &#123; url &quot;https://jitpack.io&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="2-Error-Execution-failed-for-task-‘-app-lintVitalRelease’-gt-java-lang-NullPointerException-no-error-message"><a href="#2-Error-Execution-failed-for-task-‘-app-lintVitalRelease’-gt-java-lang-NullPointerException-no-error-message" class="headerlink" title="2.Error:Execution failed for task ‘:app:lintVitalRelease’. &gt; java.lang.NullPointerException (no error message)"></a>2.Error:Execution failed for task ‘:app:lintVitalRelease’. &gt; java.lang.NullPointerException (no error message)</h3><p><strong>问题描述:</strong>react native编译报错</p><p><strong>解决方法:</strong> </p><ul><li>1.执行命令  ./gradlew app:assembleRelease -x lintVitalRelease</li><li>2.android － app － build.gradle 里面添加<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"> lintOptions &#123; checkReleaseBuilds false &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要说升级Android Studio3.0 的几个问题及解决方法&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Android/"/>
    
      <category term="Android Studio" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>深入了解Volley</title>
    <link href="https://www.jianshu.com/u/3e759a2c717f/2017/08/07/Volley%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://www.jianshu.com/u/3e759a2c717f/2017/08/07/Volley源码分析/</id>
    <published>2017-08-07T08:07:36.000Z</published>
    <updated>2019-01-24T09:34:03.379Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要说Volley的使用及分析源码，从而深入了解Volley<br><a id="more"></a></p><h1 id="一-Volley的基本使用"><a href="#一-Volley的基本使用" class="headerlink" title="一.Volley的基本使用"></a>一.Volley的基本使用</h1><h2 id="1-volley简单使用"><a href="#1-volley简单使用" class="headerlink" title="1.volley简单使用"></a>1.volley简单使用</h2><ul><li><h3 id="1-创建一个RequestQueue"><a href="#1-创建一个RequestQueue" class="headerlink" title="1.创建一个RequestQueue"></a>1.创建一个RequestQueue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RequestQueue requestQueue = Volley.newReequestQueue(context);</span><br></pre></td></tr></table></figure></li><li><h3 id="2-创建一个StringRequest对象"><a href="#2-创建一个StringRequest对象" class="headerlink" title="2.创建一个StringRequest对象"></a>2.创建一个StringRequest对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">StringRequest sq = new StringRequest(&quot;www.baidu.com&quot;,new Request.Listener&lt;String&gt;()&#123;</span><br><span class="line">    @overide</span><br><span class="line">    public void onRespose(String res)&#123;</span><br><span class="line">        Log.d(&quot;TAG&quot;,res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,new Respose.ErrorListener()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onErrorRespose(VolleyError error)&#123;</span><br><span class="line">        log.e(&quot;TAG&quot;,error.getMessage(),error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><h3 id="3-把StringRequest对象添加到RequestQueue"><a href="#3-把StringRequest对象添加到RequestQueue" class="headerlink" title="3.把StringRequest对象添加到RequestQueue"></a>3.把StringRequest对象添加到RequestQueue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestQueue.add(sq);</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-其他"><a href="#2-其他" class="headerlink" title="2.其他"></a>2.其他</h2><h4 id="StringRequest的请求方式-—四参构造方法"><a href="#StringRequest的请求方式-—四参构造方法" class="headerlink" title="StringRequest的请求方式 —四参构造方法"></a>StringRequest的请求方式 —四参构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StringRequest stringRequest = new StringRequest(Method.POST, url,  listener, errorListener) &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    protected Map&lt;String, String&gt; getParams() throws AuthFailureError &#123;  </span><br><span class="line">        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();  </span><br><span class="line">        map.put(&quot;params1&quot;, &quot;value1&quot;);  </span><br><span class="line">        map.put(&quot;params2&quot;, &quot;value2&quot;);  </span><br><span class="line">        return map;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="JsonRequest的用法"><a href="#JsonRequest的用法" class="headerlink" title="JsonRequest的用法"></a>JsonRequest的用法</h4><p>StringRequest，JsonRequest也是继承自Request类的不过由于JsonRequest是一个抽象类，因此我们无法直接创建它的实例，那么只能从它的子类入手了。JsonRequest有两个直接的子类，JsonObjectRequest和JsonArrayRequest<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JsonObjectRequest jsonObjectRequest = new JsonObjectRequest(&quot;http://m.weather.com.cn/data/101010100.html&quot;,null,new Respose.Listener&lt;JSONObject&gt;()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onRespose(JSONObject respose)&#123;</span><br><span class="line">        log.d(&quot;TAG&quot;,response.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,new Respose.ErrorListener()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onErrorListener(VolleyError error)&#123;</span><br><span class="line">        Log.e(&quot;TAG&quot;,error.getMessage(),error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">//最后把它添加到RequestQueue就可以了</span><br><span class="line">mQueue.add(jsonObjectRequest);</span><br></pre></td></tr></table></figure></p><h1 id="2-使用Volley加载网络图片"><a href="#2-使用Volley加载网络图片" class="headerlink" title="2.使用Volley加载网络图片"></a>2.使用Volley加载网络图片</h1><h2 id="1-ImageRequest的用法"><a href="#1-ImageRequest的用法" class="headerlink" title="1.ImageRequest的用法"></a>1.ImageRequest的用法</h2><h3 id="1-创建RequestQueue对象"><a href="#1-创建RequestQueue对象" class="headerlink" title="1.创建RequestQueue对象"></a>1.创建RequestQueue对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RequestQueue rq = Volley.newRequestQueue(context);</span><br></pre></td></tr></table></figure><h3 id="2-创建ImageRequest对像"><a href="#2-创建ImageRequest对像" class="headerlink" title="2.创建ImageRequest对像"></a>2.创建ImageRequest对像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ImageRequest ir = new ImageRequest(&quot;image_url&quot;,new Respose&gt;listener&lt;Bitmap&gt;()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onRespose(Bitmap res)&#123;</span><br><span class="line">        imageview.setImageBitmap(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,0,0,Config.RGB_565,new Response.ErrorListener()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onErrorRespose(VolleyReeor error)&#123;</span><br><span class="line">        imageView.setImageResource(R.drawable.default_image);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到，ImageRequest的构造函数接收六个参数，第一个参数就是图片的URL地址，这个没什么需要解释的。第二个参数是图片请求成功的回调，这里我们把返回的Bitmap参数设置到ImageView中。第三第四个参数分别用于指定允许图片最大的宽度和高度，如果指定的网络图片的宽度或高度大于这里的最大值，则会对图片进行压缩，指定成0的话就表示不管图片有多大，都不会进行压缩。第五个参数用于指定图片的颜色属性，Bitmap.Config下的几个常量都可以在这里使用，其中ARGB_8888可以展示最好的颜色属性，每个图片像素占据4个字节的大小，而RGB_565则表示每个图片像素占据2个字节大小。第六个参数是图片请求失败的回调，这里我们当请求失败时在ImageView中显示一张默认图片。</p><h3 id="3-最后将ImageRequest对象添加到RequestQueue中"><a href="#3-最后将ImageRequest对象添加到RequestQueue中" class="headerlink" title="3.最后将ImageRequest对象添加到RequestQueue中"></a>3.最后将ImageRequest对象添加到RequestQueue中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mQueue.add(imageRequest);</span><br></pre></td></tr></table></figure><h2 id="2-ImageLoader的用法"><a href="#2-ImageLoader的用法" class="headerlink" title="2.ImageLoader的用法"></a>2.ImageLoader的用法</h2><p>由于ImageLoader已经不是继承自Request的了，所以它的用法也和我们之前学到的内容有所不同，总结起来大致可以分为以下四步：</p><h4 id="1-创建一个RequestQueue对象。"><a href="#1-创建一个RequestQueue对象。" class="headerlink" title="1. 创建一个RequestQueue对象。"></a>1. 创建一个RequestQueue对象。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RequestQueue rq = Volley.newRequestQueue(context);</span><br></pre></td></tr></table></figure><h4 id="2-创建一个ImageLoader对象。"><a href="#2-创建一个ImageLoader对象。" class="headerlink" title="2. 创建一个ImageLoader对象。"></a>2. 创建一个ImageLoader对象。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ImageLoader imageLoader = new ImageLoader(rq,new ImageCache()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void putBitmap(String url,Bitmap bitmap)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Bitmap getBitmap(String url)&#123;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="3-获取一个ImageListener对象。"><a href="#3-获取一个ImageListener对象。" class="headerlink" title="3. 获取一个ImageListener对象。"></a>3. 获取一个ImageListener对象。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageListener listener = ImageLoader.getImagerListener(imageview,R.drawable.default,R.drawable.failed_image);</span><br></pre></td></tr></table></figure><p>我们通过调用ImageLoader的getImageListener()方法能够获取到一个ImageListener对象，getImageListener()方法接收三个参数，第一个参数指定用于显示图片的ImageView控件，第二个参数指定加载图片的过程中显示的图片，第三个参数指定加载图片失败的情况下显示的图片。</p><h4 id="4-调用ImageLoader的get-方法加载网络上的图片。"><a href="#4-调用ImageLoader的get-方法加载网络上的图片。" class="headerlink" title="4. 调用ImageLoader的get()方法加载网络上的图片。"></a>4. 调用ImageLoader的get()方法加载网络上的图片。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageLoader.get(&quot;image_url&quot;,listener);</span><br></pre></td></tr></table></figure><p>get()方法接收两个参数，第一个参数就是图片的URL地址，第二个参数则是刚刚获取到的ImageListener对象。当然，如果你想对图片的大小进行限制，也可以使用get()方法的重载，指定图片允许的最大宽度和高度，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageLoader.get(&quot;http://img.my.csdn.net/uploads/201404/13/1397393290_5765.jpeg&quot;,  listener, 200, 200);</span><br></pre></td></tr></table></figure></p><h1 id="三-定制自己的Request"><a href="#三-定制自己的Request" class="headerlink" title="三 定制自己的Request"></a>三 定制自己的Request</h1><p>主要参考StringRequest 继承Request<t><br>首先是StringRequest的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A canned request for retrieving the response body at a given URL as a String.</span><br><span class="line"> */</span><br><span class="line">public class StringRequest extends Request&lt;String&gt; &#123;</span><br><span class="line">    private final Listener&lt;String&gt; mListener;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates a new request with the given method.</span><br><span class="line">     *</span><br><span class="line">     * @param method the request &#123;@link Method&#125; to use</span><br><span class="line">     * @param url URL to fetch the string at</span><br><span class="line">     * @param listener Listener to receive the String response</span><br><span class="line">     * @param errorListener Error listener, or null to ignore errors</span><br><span class="line">     */</span><br><span class="line">    public StringRequest(int method, String url, Listener&lt;String&gt; listener,</span><br><span class="line">            ErrorListener errorListener) &#123;</span><br><span class="line">        super(method, url, errorListener);</span><br><span class="line">        mListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates a new GET request.</span><br><span class="line">     *</span><br><span class="line">     * @param url URL to fetch the string at</span><br><span class="line">     * @param listener Listener to receive the String response</span><br><span class="line">     * @param errorListener Error listener, or null to ignore errors</span><br><span class="line">     */</span><br><span class="line">    public StringRequest(String url, Listener&lt;String&gt; listener, ErrorListener errorListener) &#123;</span><br><span class="line">        this(Method.GET, url, listener, errorListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void deliverResponse(String response) &#123;</span><br><span class="line">        mListener.onResponse(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Response&lt;String&gt; parseNetworkResponse(NetworkResponse response) &#123;</span><br><span class="line">        String parsed;</span><br><span class="line">        try &#123;</span><br><span class="line">            parsed = new String(response.data, HttpHeaderParser.parseCharset(response.headers));</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            parsed = new String(response.data);</span><br><span class="line">        &#125;</span><br><span class="line">        return Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p><p>可以看到，StringRequest的源码很简练，根本就没几行代码，我们一起来分析下。首先StringRequest是继承自Request类的，Request可以指定一个泛型类，这里指定的当然就是String了，接下来StringRequest中提供了两个有参的构造函数，参数包括请求类型，请求地址，以及响应回调等，由于我们已经很熟悉StringRequest的用法了，相信这几个参数的作用都不用再解释了吧。但需要注意的是，在构造函数中一定要调用super()方法将这几个参数传给父类，因为HTTP的请求和响应都是在父类中自动处理的。</p><p>另外，由于Request类中的deliverResponse()和parseNetworkResponse()是两个抽象方法，因此StringRequest中需要对这两个方法进行实现。deliverResponse()方法中的实现很简单，仅仅是调用了mListener中的onResponse()方法，并将response内容传入即可，这样就可以将服务器响应的数据进行回调了。parseNetworkResponse()方法中则应该对服务器响应的数据进行解析，其中数据是以字节的形式存放在NetworkResponse的data变量中的，这里将数据取出然后组装成一个String，并传入Response的success()方法中即可。</p><p>下面我们就可以动手来尝试实现一下XMLRequest了，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class XMLRequest extends Request&lt;XmlPullParser&gt; &#123;</span><br><span class="line"></span><br><span class="line">private final Listener&lt;XmlPullParser&gt; mListener;</span><br><span class="line"></span><br><span class="line">public XMLRequest(int method, String url, Listener&lt;XmlPullParser&gt; listener,</span><br><span class="line">ErrorListener errorListener) &#123;</span><br><span class="line">super(method, url, errorListener);</span><br><span class="line">mListener = listener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public XMLRequest(String url, Listener&lt;XmlPullParser&gt; listener, ErrorListener errorListener) &#123;</span><br><span class="line">this(Method.GET, url, listener, errorListener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected Response&lt;XmlPullParser&gt; parseNetworkResponse(NetworkResponse response) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">String xmlString = new String(response.data,</span><br><span class="line">HttpHeaderParser.parseCharset(response.headers));</span><br><span class="line">XmlPullParserFactory factory = XmlPullParserFactory.newInstance();</span><br><span class="line">XmlPullParser xmlPullParser = factory.newPullParser();</span><br><span class="line">xmlPullParser.setInput(new StringReader(xmlString));</span><br><span class="line">return Response.success(xmlPullParser, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">&#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">return Response.error(new ParseError(e));</span><br><span class="line">&#125; catch (XmlPullParserException e) &#123;</span><br><span class="line">return Response.error(new ParseError(e));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void deliverResponse(XmlPullParser response) &#123;</span><br><span class="line">mListener.onResponse(response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="自定义GsonRequest"><a href="#自定义GsonRequest" class="headerlink" title="自定义GsonRequest"></a>自定义GsonRequest</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class GsonRequest&lt;T&gt; extends Request&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">private final Listener&lt;T&gt; mListener;</span><br><span class="line"></span><br><span class="line">private Gson mGson;</span><br><span class="line"></span><br><span class="line">private Class&lt;T&gt; mClass;</span><br><span class="line"></span><br><span class="line">public GsonRequest(int method, String url, Class&lt;T&gt; clazz, Listener&lt;T&gt; listener,</span><br><span class="line">ErrorListener errorListener) &#123;</span><br><span class="line">super(method, url, errorListener);</span><br><span class="line">mGson = new Gson();</span><br><span class="line">mClass = clazz;</span><br><span class="line">mListener = listener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public GsonRequest(String url, Class&lt;T&gt; clazz, Listener&lt;T&gt; listener,</span><br><span class="line">ErrorListener errorListener) &#123;</span><br><span class="line">this(Method.GET, url, clazz, listener, errorListener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected Response&lt;T&gt; parseNetworkResponse(NetworkResponse response) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">String jsonString = new String(response.data,</span><br><span class="line">HttpHeaderParser.parseCharset(response.headers));</span><br><span class="line">return Response.success(mGson.fromJson(jsonString, mClass),</span><br><span class="line">HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">&#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">return Response.error(new ParseError(e));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void deliverResponse(T response) &#123;</span><br><span class="line">mListener.onResponse(response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="带你从源码的角度理解Volley"><a href="#带你从源码的角度理解Volley" class="headerlink" title="带你从源码的角度理解Volley"></a>带你从源码的角度理解Volley</h1><p>核心思路:我们在主线程中调用RequestQueue的add()方法来添加一条网络请求，这条请求会先被加入到缓存队列当中，如果发现可以找到相应的缓存结果就直接读取缓存并解析，然后回调给主线程。如果在缓存中没有找到结果，则将这条请求加入到网络请求队列中，然后处理发送HTTP请求，解析响应结果，写入缓存，并回调主线程。</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>说起分析源码，那么应该从哪儿开始看起呢？这就要回顾一下Volley的用法了，还记得吗，使用Volley的第一步，首先要调用Volley.newRequestQueue(context)方法来获取一个RequestQueue对象，那么我们自然要从这个方法开始看起了，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static RequestQueue newRequestQueue(Context context) &#123;  </span><br><span class="line">    return newRequestQueue(context, null);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法仅仅只有一行代码，只是调用了newRequestQueue()的方法重载，并给第二个参数传入null。那我们看下带有两个参数的newRequestQueue()方法中的代码，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static RequestQueue newRequestQueue(Context content,HttpStack stack)&#123;</span><br><span class="line">  File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);  </span><br><span class="line">    String userAgent = &quot;volley/0&quot;;  </span><br><span class="line">    try &#123;  </span><br><span class="line">        String packageName = context.getPackageName();  </span><br><span class="line">        PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);  </span><br><span class="line">        userAgent = packageName + &quot;/&quot; + info.versionCode;  </span><br><span class="line">    &#125; catch (NameNotFoundException e) &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (stack == null) &#123;  </span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= 9) &#123;  </span><br><span class="line">            stack = new HurlStack();  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    Network network = new BasicNetwork(stack);  </span><br><span class="line">    RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network);  </span><br><span class="line">    queue.start();  </span><br><span class="line">    return queue;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，这里在第10行判断如果stack是等于null的，则去创建一个HttpStack对象，这里会判断如果手机系统版本号是大于9的，则创建一个HurlStack的实例，否则就创建一个HttpClientStack的实例。实际上HurlStack的内部就是使用HttpURLConnection进行网络通讯的，而HttpClientStack的内部则是使用HttpClient进行网络通讯的，这里为什么这样选择呢？可以参考我之前翻译的一篇文章Android访问网络，使用HttpURLConnection还是HttpClient？</p><p>创建好了HttpStack之后，接下来又创建了一个Network对象，它是用于根据传入的HttpStack对象来处理网络请求的，紧接着new出一个RequestQueue对象，并调用它的start()方法进行启动，然后将RequestQueue返回，这样newRequestQueue()的方法就执行结束了。</p><p>那么RequestQueue的start()方法内部到底执行了什么东西呢？我们跟进去瞧一瞧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void start() &#123;  </span><br><span class="line">    stop();  // Make sure any currently running dispatchers are stopped.  </span><br><span class="line">    // Create the cache dispatcher and start it.  </span><br><span class="line">    mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);  </span><br><span class="line">    mCacheDispatcher.start();  </span><br><span class="line">    // Create network dispatchers (and corresponding threads) up to the pool size.  </span><br><span class="line">    for (int i = 0; i &lt; mDispatchers.length; i++) &#123;  </span><br><span class="line">        NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,  </span><br><span class="line">                mCache, mDelivery);  </span><br><span class="line">        mDispatchers[i] = networkDispatcher;  </span><br><span class="line">        networkDispatcher.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里先是创建了一个CacheDispatcher的实例，然后调用了它的start()方法，接着在一个for循环里去创建NetworkDispatcher的实例，并分别调用它们的start()方法。这里的CacheDispatcher和NetworkDispatcher都是继承自Thread的，而默认情况下for循环会执行四次，也就是说当调用了Volley.newRequestQueue(context)之后，就会有五个线程一直在后台运行，不断等待网络请求的到来，其中CacheDispatcher是缓存线程，NetworkDispatcher是网络请求线程。</p><h3 id="addRequest"><a href="#addRequest" class="headerlink" title="addRequest"></a>addRequest</h3><p>得到了RequestQueue之后，我们只需要构建出相应的Request，然后调用RequestQueue的add()方法将Request传入就可以完成网络请求操作了，那么不用说，add()方法的内部肯定有着非常复杂的逻辑，我们来一起看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request) &#123;  </span><br><span class="line">    // Tag the request as belonging to this queue and add it to the set of current requests.  </span><br><span class="line">    request.setRequestQueue(this);  </span><br><span class="line">    synchronized (mCurrentRequests) &#123;  </span><br><span class="line">        mCurrentRequests.add(request);  </span><br><span class="line">    &#125;  </span><br><span class="line">    // Process requests in the order they are added.  </span><br><span class="line">    request.setSequence(getSequenceNumber());  </span><br><span class="line">    request.addMarker(&quot;add-to-queue&quot;);  </span><br><span class="line">    // If the request is uncacheable, skip the cache queue and go straight to the network.  </span><br><span class="line">    if (!request.shouldCache()) &#123;  </span><br><span class="line">        mNetworkQueue.add(request);  </span><br><span class="line">        return request;  </span><br><span class="line">    &#125;  </span><br><span class="line">    // Insert request into stage if there&apos;s already a request with the same cache key in flight.  </span><br><span class="line">    synchronized (mWaitingRequests) &#123;  </span><br><span class="line">        String cacheKey = request.getCacheKey();  </span><br><span class="line">        if (mWaitingRequests.containsKey(cacheKey)) &#123;  </span><br><span class="line">            // There is already a request in flight. Queue up.  </span><br><span class="line">            Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);  </span><br><span class="line">            if (stagedRequests == null) &#123;  </span><br><span class="line">                stagedRequests = new LinkedList&lt;Request&lt;?&gt;&gt;();  </span><br><span class="line">            &#125;  </span><br><span class="line">            stagedRequests.add(request);  </span><br><span class="line">            mWaitingRequests.put(cacheKey, stagedRequests);  </span><br><span class="line">            if (VolleyLog.DEBUG) &#123;  </span><br><span class="line">                VolleyLog.v(&quot;Request for cacheKey=%s is in flight, putting on hold.&quot;, cacheKey);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            // Insert &apos;null&apos; queue for this cacheKey, indicating there is now a request in  </span><br><span class="line">            // flight.  </span><br><span class="line">            mWaitingRequests.put(cacheKey, null);  </span><br><span class="line">            mCacheQueue.add(request);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return request;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，在第11行的时候会判断当前的请求是否可以缓存，如果不能缓存则在第12行直接将这条请求加入网络请求队列，可以缓存的话则在第33行将这条请求加入缓存队列。在默认情况下，每条请求都是可以缓存的，当然我们也可以调用Request的setShouldCache(false)方法来改变这一默认行为。</p><p>OK，那么既然默认每条请求都是可以缓存的，自然就被添加到了缓存队列中，于是一直在后台等待的缓存线程就要开始运行起来了，我们看下CacheDispatcher中的run()方法，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public class CacheDispatcher extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (DEBUG) VolleyLog.v(&quot;start new dispatcher&quot;);</span><br><span class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">        // Make a blocking call to initialize the cache.</span><br><span class="line">        mCache.initialize();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // Get a request from the cache triage queue, blocking until</span><br><span class="line">                // at least one is available.</span><br><span class="line">                final Request&lt;?&gt; request = mCacheQueue.take();</span><br><span class="line">                request.addMarker(&quot;cache-queue-take&quot;);</span><br><span class="line">                // If the request has been canceled, don&apos;t bother dispatching it.</span><br><span class="line">                if (request.isCanceled()) &#123;</span><br><span class="line">                    request.finish(&quot;cache-discard-canceled&quot;);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                // Attempt to retrieve this item from cache.</span><br><span class="line">                Cache.Entry entry = mCache.get(request.getCacheKey());</span><br><span class="line">                if (entry == null) &#123;</span><br><span class="line">                    request.addMarker(&quot;cache-miss&quot;);</span><br><span class="line">                    // Cache miss; send off to the network dispatcher.</span><br><span class="line">                    mNetworkQueue.put(request);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                // If it is completely expired, just send it to the network.</span><br><span class="line">                if (entry.isExpired()) &#123;</span><br><span class="line">                    request.addMarker(&quot;cache-hit-expired&quot;);</span><br><span class="line">                    request.setCacheEntry(entry);</span><br><span class="line">                    mNetworkQueue.put(request);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                // We have a cache hit; parse its data for delivery back to the request.</span><br><span class="line">                request.addMarker(&quot;cache-hit&quot;);</span><br><span class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(</span><br><span class="line">                        new NetworkResponse(entry.data, entry.responseHeaders));</span><br><span class="line">                request.addMarker(&quot;cache-hit-parsed&quot;);</span><br><span class="line">                if (!entry.refreshNeeded()) &#123;</span><br><span class="line">                    // Completely unexpired cache hit. Just deliver the response.</span><br><span class="line">                    mDelivery.postResponse(request, response);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // Soft-expired cache hit. We can deliver the cached response,</span><br><span class="line">                    // but we need to also send the request to the network for</span><br><span class="line">                    // refreshing.</span><br><span class="line">                    request.addMarker(&quot;cache-hit-refresh-needed&quot;);</span><br><span class="line">                    request.setCacheEntry(entry);</span><br><span class="line">                    // Mark the response as intermediate.</span><br><span class="line">                    response.intermediate = true;</span><br><span class="line">                    // Post the intermediate response back to the user and have</span><br><span class="line">                    // the delivery then forward the request along to the network.</span><br><span class="line">                    mDelivery.postResponse(request, response, new Runnable() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                mNetworkQueue.put(request);</span><br><span class="line">                            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                                // Not much we can do about this.</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                // We may have been interrupted because it was time to quit.</span><br><span class="line">                if (mQuit) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码有点长，我们只挑重点看。首先在11行可以看到一个while(true)循环，说明缓存线程始终是在运行的，接着在第23行会尝试从缓存当中取出响应结果，如何为空的话则把这条请求加入到网络请求队列中，如果不为空的话再判断该缓存是否已过期，如果已经过期了则同样把这条请求加入到网络请求队列中，否则就认为不需要重发网络请求，直接使用缓存中的数据即可。之后会在第39行调用Request的parseNetworkResponse()方法来对数据进行解析，再往后就是将解析出来的数据进行回调了，这部分代码我们先跳过，因为它的逻辑和NetworkDispatcher后半部分的逻辑是基本相同的，那么我们等下合并在一起看就好了，先来看一下NetworkDispatcher中是怎么处理网络请求队列的，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class NetworkDispatcher extends Thread &#123;</span><br><span class="line">……</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">        Request&lt;?&gt; request;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // Take a request from the queue.</span><br><span class="line">                request = mQueue.take();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                // We may have been interrupted because it was time to quit.</span><br><span class="line">                if (mQuit) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                request.addMarker(&quot;network-queue-take&quot;);</span><br><span class="line">                // If the request was cancelled already, do not perform the</span><br><span class="line">                // network request.</span><br><span class="line">                if (request.isCanceled()) &#123;</span><br><span class="line">                    request.finish(&quot;network-discard-cancelled&quot;);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                addTrafficStatsTag(request);</span><br><span class="line">                // Perform the network request.</span><br><span class="line">                NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br><span class="line">                request.addMarker(&quot;network-http-complete&quot;);</span><br><span class="line">                // If the server returned 304 AND we delivered a response already,</span><br><span class="line">                // we&apos;re done -- don&apos;t deliver a second identical response.</span><br><span class="line">                if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</span><br><span class="line">                    request.finish(&quot;not-modified&quot;);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                // Parse the response here on the worker thread.</span><br><span class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</span><br><span class="line">                request.addMarker(&quot;network-parse-complete&quot;);</span><br><span class="line">                // Write to cache if applicable.</span><br><span class="line">                // TODO: Only update cache metadata instead of entire record for 304s.</span><br><span class="line">                if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123;</span><br><span class="line">                    mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class="line">                    request.addMarker(&quot;network-cache-written&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                // Post the response back.</span><br><span class="line">                request.markDelivered();</span><br><span class="line">                mDelivery.postResponse(request, response);</span><br><span class="line">            &#125; catch (VolleyError volleyError) &#123;</span><br><span class="line">                parseAndDeliverNetworkError(request, volleyError);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString());</span><br><span class="line">                mDelivery.postError(request, new VolleyError(e));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要说Volley的使用及分析源码，从而深入了解Volley&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Android/"/>
    
      <category term="Volley" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Volley/"/>
    
  </entry>
  
  <entry>
    <title>Android高效加载大图、多图解决方案，有效避免程序OOM</title>
    <link href="https://www.jianshu.com/u/3e759a2c717f/2017/08/03/Android%E9%AB%98%E6%95%88%E5%8A%A0%E8%BD%BD%E5%A4%A7%E5%9B%BE%E3%80%81%E5%A4%9A%E5%9B%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%8C%E6%9C%89%E6%95%88%E9%81%BF%E5%85%8D%E7%A8%8B%E5%BA%8FOOM/"/>
    <id>https://www.jianshu.com/u/3e759a2c717f/2017/08/03/Android高效加载大图、多图解决方案，有效避免程序OOM/</id>
    <published>2017-08-03T08:07:36.000Z</published>
    <updated>2019-01-24T09:34:50.523Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要说Android高效加载大图、多图解决的方案，可以有效避免Android程序OOM<br><a id="more"></a></p><h1 id="一-高效加载大图"><a href="#一-高效加载大图" class="headerlink" title="一.高效加载大图"></a>一.高效加载大图</h1><h3 id="1-查看程序可用内存大小"><a href="#1-查看程序可用内存大小" class="headerlink" title="1.查看程序可用内存大小"></a>1.查看程序可用内存大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int maxMemory = (int)(Runtime.getRuntime().maxMemory()/1024);</span><br><span class="line">Log.d(&quot;TAG&quot;,&quot;Max memory is &quot;+maxmoory+&quot;KB&quot;);</span><br></pre></td></tr></table></figure><p>因此在展示高分辨率图片的时候，最好先将图片进行压缩。压缩后的图片大小应该和用来展示它的控件大小相近，在一个很小的ImageView上显示一张超大的图片不会带来任何视觉上的好处，但却会占用我们相当多宝贵的内存，而且在性能上还可能会带来负面影响。</p><p>每一种解析方法都提供了一个可选的BitmapFactory.Options参数，将这个参数的inJustDecodeBounds属性设置为true就可以让解析方法禁止为bitmap分配内存，返回值也不再是一个Bitmap对象，而是null。虽然Bitmap是null了，但是BitmapFactory.Options的outWidth、outHeight和outMimeType属性都会被赋值。这个技巧让我们可以在加载图片之前就获取到图片的长宽值和MIME类型，从而根据情况对图片进行压缩。如下代码所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BitmapFactory.Options options = new BitmapFactory.Options();</span><br><span class="line">options.inJustDecodeBounds = true;//禁止为Bitmap分配内存</span><br><span class="line">BitmapFactory.decodeResource(getResources(),R.id.myimage,options);</span><br><span class="line">int imageHeihht = options.outHeight;</span><br><span class="line">int imageWidth = options.outWidth;</span><br><span class="line">String imageType = options.outMimeType;</span><br></pre></td></tr></table></figure></p><p>加载图片前考虑是完整显示图片还是要压缩后再显示,就需要考虑以下因素:</p><ul><li>预估整张图片占用的内存</li><li>为了加在一张图片,你愿意提供多少内存</li><li>用于展示的图片控件的实际大小</li><li>当前设备的屏幕尺寸和分辨率<br>对图片压缩需要使用BitmapFactory.Options中的inSampleSize(例如:2048 <em> 1536像素的图片,inSampleSize= 4,图片被压缩成 512 </em> 384 所占的内存大小为512 <em> 384 </em>4 = 0.75M (假设图片是ARGB_8888类型，即每个像素点占用4个字节)<br>下面的方法可以根据宽高计算出合适的inSampleSize值:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static int calculateInSampleSize(BitmapFactory.Options options,int reqWidth,int reqHeight)&#123;</span><br><span class="line">    //源图片的高度和宽度</span><br><span class="line">    final int height  = options.outHeight;</span><br><span class="line">    final int width = options.outWidth;</span><br><span class="line">    int inSampleSaze= 1;</span><br><span class="line">    if(height&gt;reqHeight||width&gt;reqWidth)&#123;</span><br><span class="line">        //计算实际宽高和目标宽高的比率</span><br><span class="line">        final int heightRatio = Math.round((float)height/(float)reqHeight);</span><br><span class="line">        final int widthRatio = Math.round((float)height/(float)reqHeight);</span><br><span class="line">        //选择宽高比例较小的作为InSampleSize的值,这样保证最终图片的宽高是大于目标的宽高</span><br><span class="line">        inSampleSize = heightRatio&gt;widthRatio?widthRatio:heightRatio;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return inSampleSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>获取到inSampleSize值以后再把inJustDecodeBounds设置为false,就可以使用压缩后的图片了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static Bitmap decodeSampleBitmapFromResource(Resources res,int resId,int reqWidth,int reqHeight)&#123;</span><br><span class="line">    //第一次设置inJustDecodeBounds为true,来获取图片大小</span><br><span class="line">    final BitmapFactory.Options options = new BitmapFactory.Options();</span><br><span class="line">    options.inJustDecodeBounds = true;</span><br><span class="line">    BitmapFactory.decodeResource(res,resId,options);</span><br><span class="line">    //调用方法计算inSampleSize</span><br><span class="line">    options.inSampleSize = calculateInSampleSize(options,reqWidth,reqHeight);</span><br><span class="line">    //使用insamplesize在此解析图片</span><br><span class="line">    options.inJustDecodeBounds = false;</span><br><span class="line">    return BitmapFactory.decodeResource(res,resId,options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面的代码非常简单的将任意一张图片设置压缩成100*100的缩略图,并显示在ImageView上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mImageView.setImageBitmap(decodeSampleBitmapFromResource(getResource(),R.id.myimage,100,100));</span><br></pre></td></tr></table></figure></p><hr><h1 id="二-使用图片缓存技术"><a href="#二-使用图片缓存技术" class="headerlink" title="二.使用图片缓存技术"></a>二.使用图片缓存技术</h1><p>防止频繁的显示多张图片 以及回收过的图片再次显示导致大量的加载而引起OOM</p><p>内存缓存技术对那些大量占用应用程序宝贵内存的图片提供了快速访问的方法。其中最核心的类是LruCache (此类在android-support-v4的包中提供) 。这个类非常适合用来缓存图片，它的主要算法原理是==把最近使用的对象用强引用存储在 LinkedHashMap 中，并且把最近最少使用的对象在缓存值达到预设定值之前从内存中移除。==</p><p>为了能够选择一个合适的缓存大小给LruCache, 有以下多个因素应该放入考虑范围内，例如：</p><ul><li>你的设备可以为每个应用程序分配多大的内存？</li><li>设备屏幕上一次最多能显示多少张图片？有多少图片需要进行预加载，因为有可能很快也会显示在屏幕上？</li><li>你的设备的屏幕大小和分辨率分别是多少？一个超高分辨率的设备（例如 Galaxy Nexus) 比起一个较低分辨率的设备（例如 Nexus S），在持有相同数量图片的时候，需要更大的缓存空间。</li><li>图片的尺寸和大小，还有每张图片会占据多少内存空间。</li><li>图片被访问的频率有多高？会不会有一些图片的访问频率比其它图片要高？如果有的话，你也许应该让一些图片常驻在内存当中，或者使用多个LruCache 对象来区分不同组的图片。</li><li>你能维持好数量和质量之间的平衡吗？有些时候，存储多个低像素的图片，而在后台去开线程加载高像素的图片会更加的有效</li></ul><p>下面是一个使用 LruCache 来缓存图片的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private LruCache&lt;String,Bitmap&gt;mMemoryChahe;</span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState)&#123;</span><br><span class="line">    / 获取到可用内存的最大值，使用内存超出这个值会引起OutOfMemory异常。  </span><br><span class="line">    // LruCache通过构造函数传入缓存值，以KB为单位。  </span><br><span class="line">     int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);  </span><br><span class="line">    // 使用最大可用内存值的1/8作为缓存的大小。  </span><br><span class="line">    int cacheSize = maxMemory / 8; </span><br><span class="line">    mMemoryCache = new LruCache&lt;String,Bitmap&gt;(cacheSize)&#123;</span><br><span class="line">        @Override</span><br><span class="line">        protect int sizeOf(String key,Bitmap bitmap)&#123;</span><br><span class="line">            //重写此方法来衡量每张图片的大小,默认返回图片数量.</span><br><span class="line">            return bitmap.getByteCount()/1024;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void addBitmapToMemoryCache(String key,Bitmap bitmap)&#123;</span><br><span class="line">    if(getBitmapFromMemCache(key)==null)&#123;</span><br><span class="line">        mMemoryCache.put(key,bitmap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public Bitmap getBitmapFromMemoryCache(String key)&#123;</span><br><span class="line">    return mMemoryCache.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子当中，使用了系统分配给应用程序的八分之一内存来作为缓存大小。在中高配置的手机当中，这大概会有4兆(32/8)的缓存空间。一个全屏幕的 GridView 使用4张 800x480分辨率的图片来填充，则大概会占用1.5兆的空间(800 <em> 480 </em> 4)。因此，这个缓存大小可以存储2.5页的图片。</p><p>当向 ImageView 中加载一张图片时,首先会在 LruCache 的缓存中进行检查。如果找到了相应的键值，则会立刻更新ImageView ，否则开启一个后台线程来加载这张图片。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void loadBitmap(int resId,ImageView imageview)&#123;</span><br><span class="line">    final String imageKay = String valueOf(resId);</span><br><span class="line">    Bitmap bitmap = mMemoryCache.getBitmapFromMemoryCache(imageKey);</span><br><span class="line">    if(bitmap!=null)&#123;</span><br><span class="line">        imageview.setImageBitmap(bitmap);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        imageview.setImageResource(R.drawable.image_placeholder);</span><br><span class="line">        //缓存</span><br><span class="line">        BitmapWorkerTask task = new BitmapWorkTask(imageview);</span><br><span class="line">        task.execute(resId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BitmapWorkerTask extends AsyncTask&lt;Integer,Void,Bitmap&gt;&#123;</span><br><span class="line">    //异步加载图片</span><br><span class="line">    @Override</span><br><span class="line">    protected Bitmap doInBackground(Integer...params)&#123;</span><br><span class="line">        final Bitmap bitmap = edcodeSampleBitmapFromResource(getResource(),params[0],100,100);</span><br><span class="line">        addBitmapToMemoryCache(String.valueOf(params[0],bitmap));</span><br><span class="line">        return bitmap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要说Android高效加载大图、多图解决的方案，可以有效避免Android程序OOM&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Android/"/>
    
      <category term="OOM" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/OOM/"/>
    
      <category term="Image" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Image/"/>
    
  </entry>
  
  <entry>
    <title>Android设备root下使用Shell调用ADB指令方式来点击屏幕</title>
    <link href="https://www.jianshu.com/u/3e759a2c717f/2017/06/06/%E4%BD%BF%E7%94%A8Shell%E8%B0%83%E7%94%A8ADB%E6%8C%87%E4%BB%A4%E6%96%B9%E5%BC%8F%E6%9D%A5%E7%82%B9%E5%87%BB%E5%B1%8F%E5%B9%95/"/>
    <id>https://www.jianshu.com/u/3e759a2c717f/2017/06/06/使用Shell调用ADB指令方式来点击屏幕/</id>
    <published>2017-06-06T08:17:36.000Z</published>
    <updated>2019-01-24T09:26:04.560Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要说Android设备root下使用Shell调用ADB指令方式来点击屏幕<br><a id="more"></a></p><ol><li>背景</li></ol><hr><p>老大最近有个需求要捕获一些东西(具体不能细说),然后在需求的最关键的一个点就归结到要点击一下别的APP的一个指定位置.<br>在网上搜索安卓按键模拟。用了很多方式都不太好,最后锁定了使用ADB调试的方案，向手机发送按键事件。刚好之前做过在Root权限下，用Java调用安卓底层的Linux  Shell，然后执行pm指令使用Shell调用ADB指令.<br>    使用Java执行<br>    <code>Runtime.getRuntime().exec(&quot;su&quot;).getOutputStream()</code>，获取了一个具有Root权限的Process的输出流对象，向其中写入字符串即可以Root权限被Shell执行，ADB模拟按键的指令为   <code>input keyevent    keyCode</code>，keyCode为按键的键值，例如KeyEvent.KEYCODE_VOLUME_UP表示音量加。 至于触屏或鼠标事件，只要调用相应的ADB指令即可。但是有一点问题，就是反应速度非常慢，尤其是连续模拟多个按键的时候，甚至会死机。而按键精灵运行的就相当流畅，我又开始好奇按键精灵是怎么实现的。    后来终于还是找到了原因，模拟按键时，不应每次都调用<code>Runtime.getRuntime().exec(&quot;su&quot;)</code>，因为每次调用这个代码的时候，都会获取Runtime实例，并且执行”su”请求Root权限，反应就会很慢（我的理解是相当于每次都新开一个命令行窗口）；而应该只是在一开始执行一次，并获取一个OutputStream实例，后来每次执行一条Shell指令，只需向其中写入相应字符串，这样就快了很多。    下面贴出可用的代码。要求设备已经Root，不需要其他任何特殊权限或签名。由于用的是ADB指令，兼容性也不会有太大问题。首次运行程序时（其实也就是执行Runtime.exec(“su”)的时候），会请求Root权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用root权限执行Linux下的Shell指令</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">public class RootShell &#123;</span><br><span class="line"></span><br><span class="line">private OutputStream os;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 执行shell指令</span><br><span class="line"> * </span><br><span class="line"> * @param cmd</span><br><span class="line"> *            指令</span><br><span class="line"> */</span><br><span class="line">public final void exec(String cmd) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">if (os == null) &#123;</span><br><span class="line">os = Runtime.getRuntime().exec(&quot;su&quot;).getOutputStream();</span><br><span class="line">&#125;</span><br><span class="line">os.write(cmd.getBytes());</span><br><span class="line">os.flush();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 后台模拟全局按键</span><br><span class="line"> * </span><br><span class="line"> * @param keyCode</span><br><span class="line"> *            键值</span><br><span class="line"> */</span><br><span class="line">public final void simulateKey(int keyCode) &#123;</span><br><span class="line">exec(&quot;input keyevent &quot; + keyCode + &quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他参考博客<br><a href="http://blog.csdn.net/aimncy/article/details/20618535" target="_blank" rel="noopener">地址1</a><br><a href="http://blog.csdn.net/aminfo/article/details/7785975" target="_blank" rel="noopener">地址2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要说Android设备root下使用Shell调用ADB指令方式来点击屏幕&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Android/"/>
    
      <category term="Root" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Root/"/>
    
      <category term="ADB" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/ADB/"/>
    
  </entry>
  
  <entry>
    <title>Android集成微信支付出现的-1等错误</title>
    <link href="https://www.jianshu.com/u/3e759a2c717f/2017/06/06/Android%E9%9B%86%E6%88%90%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E7%9A%84%E5%87%BA%E7%8E%B0-1%E7%AD%89%E9%94%99%E8%AF%AF%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E8%A6%81%E7%82%B9/"/>
    <id>https://www.jianshu.com/u/3e759a2c717f/2017/06/06/Android集成微信支付的出现-1等错误需要注意的要点/</id>
    <published>2017-06-06T08:07:36.000Z</published>
    <updated>2019-01-24T09:18:03.444Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要说Android集成微信支付出现的-1等错误的解决及注意的点<br><a id="more"></a></p><h1 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h1><ol><li><p>微信支付和支付宝支付是现在APP常用的支付方式,但是真正接入过两种支付方式的猿友会很明显的感觉到微信支付真心比支付宝麻烦很多,会出现很多莫名其妙的错误,但是官方的文档却很难给出较好的解决方案.</p></li><li><p>前几天公司的APP需要支付功能然后也需要这个-1问题,简直感觉微信支付丧心病狂,这里总结下自己出现的问题和一些其他网友出现的问题做个总结,最后,欢迎补充.谢谢**</p></li></ol><h1 id="二-错误的统计"><a href="#二-错误的统计" class="headerlink" title="二.错误的统计"></a>二.错误的统计</h1><p><strong>*官方的描述: </strong>  -1    错误    可能的原因：签名错误、未注册APPID、项目设置APPID不正确、注册的APPID与设置的不匹配、其他异常等。</p><p><strong>1.签名错误:</strong></p><ul><li><p>(1).签名的参数集合没有按照参数名ASCII码从小到大排序（字典序）.</p></li><li><p>(2).签名的是时候漏了使用key,(key的由来可以看下面第三条的分析)</p></li><li>(3).签名的KEY错误. 这里用来签名的key是申请支付功能以后,微信给你的一个商户账号里面设置的.具体key设置路径：微信商户平台(pay.weixin.qq.com)–&gt;账户设置–&gt;API安全–&gt;密钥设置</li><li>(4).签名后的key没有进行转化成大写或者其他例如前面的签名参数先排好序最后才加上key(key字段不参与ASCII码的大小排序,而是直接放到最后)</li><li>(5),还有一些其他的格式错误请参看官方文档的详细说明 <a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=4_3" target="_blank" rel="noopener">微信官方的签名说明,请认真对比.</a></li><li>(6),签名问题的终极大招—–使用官方的签名认证工具一一对比.注:最好在连接生成的key和最终MD5之后的结果 在log下打印出来,可以方便查看出错的位置 <a href="https://pay.weixin.qq.com/wiki/tools/signverify/" target="_blank" rel="noopener">接口调试工具</a></li></ul><p><strong>2.APPID错误</strong></p><ul><li>(1)APPID是在open.weixin.qq.com上创建的应用,可以通过 点击管理中心–&gt;应用详情 来查看APPID<br><img src="http://img.blog.csdn.net/20160709215900458" alt="这里写图片描述"></li><li>(2)创建APP时候上传的证书与现在使用的不一致.商户在微信开放平台申请开发应用后，微信开放平台会生成APP的唯一标识APPID。由于需要保证支付安全，需要在开放平台绑定商户应用包名和应用签名，设置好后才能正常发起支付。设置界面在【开放平台】中的栏目【 管理中心 –&gt; 修改应用 –&gt; 修改开发信息】里面<br><img src="http://img.blog.csdn.net/20160709220847731" alt="这里写图片描述"><br>应用包名：是在APP项目配置文件AndroidManifest.xml中声明的package值，例如DEMO中的package=”com.nmm.paydemo”。<br>应用签名：根据项目的应用包名和编译使用的keystore，可由签名工具生成一个32位的md5串，在调试的手机上安装签名工具后，运行可生成应用签名串，如图8.9所示，绿色串即应用签名。<a href="https://open.weixin.qq.com/zh_CN/htmledition/res/dev/download/sdk/Gen_Signature_Android.apk" target="_blank" rel="noopener">签名工具下载地址</a></li></ul><p>对比查看应用签名是否一致<strong>,特别注意,一般上传都是使用release版本的key所以在测试的时候就需要使用签名版的apk,普通的debug版本key是不一致的</strong></p><p>#三.结束<br><strong>文档主要参考网络和自己的使用过程,有什么错误的地方欢迎指正</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要说Android集成微信支付出现的-1等错误的解决及注意的点&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Android/"/>
    
      <category term="微信" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>升级Android Studio2.4问题汇总</title>
    <link href="https://www.jianshu.com/u/3e759a2c717f/2017/04/24/%E5%8D%87%E7%BA%A7Android%20Studio2.4%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>https://www.jianshu.com/u/3e759a2c717f/2017/04/24/升级Android Studio2.4问题汇总/</id>
    <published>2017-04-24T08:07:36.000Z</published>
    <updated>2019-01-24T09:28:52.179Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要说升级Android Studio2.4的一些问题及解决方案<br><a id="more"></a></p><hr><h3 id="1-Warning-android-apt-plugin-is-incompatible-with-future-version-of-Android-Gradle-plugin-Please-use-‘annotationProcessor’-configuration-instead"><a href="#1-Warning-android-apt-plugin-is-incompatible-with-future-version-of-Android-Gradle-plugin-Please-use-‘annotationProcessor’-configuration-instead" class="headerlink" title="1. Warning:android-apt plugin is incompatible with future version of Android Gradle plugin.  Please use ‘annotationProcessor’ configuration instead."></a>1. Warning:android-apt plugin is incompatible with future version of Android Gradle plugin.  Please use ‘annotationProcessor’ configuration instead.</h3><p>如上图所示是完整的警告提示<br>就是说新版本这个组件是不相容的需要去除</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h4><ul><li>在 build.gradle中删除这一行  ( apply plugin: ‘android-apt’ )</li><li>删除目录app/build/generated 这个文件夹</li><li>重新编译</li></ul><hr><h3 id="2-Error-Could-not-initialize-class-com-android-ide-common-util-ReadWriteProcessLock"><a href="#2-Error-Could-not-initialize-class-com-android-ide-common-util-ReadWriteProcessLock" class="headerlink" title="2. Error:Could not initialize class com.android.ide.common.util.ReadWriteProcessLock"></a>2. Error:Could not initialize class com.android.ide.common.util.ReadWriteProcessLock</h3><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>停止这个进程,然后有两种方式来解决 :</p><p>1- File/ Invalidate Caches/Restart Android Studio,</p><p>2- 在Android Studio的Terminal 界面输入命令: ./gradlew –stop 然后重新编译项目</p><hr><h3 id="3-Warning-The-Jack-toolchain-is-deprecated-To-enable-support-for-Java-8-language-features-remove-‘jackOptions-…-’-from-your-build-gradle-file-and-add"><a href="#3-Warning-The-Jack-toolchain-is-deprecated-To-enable-support-for-Java-8-language-features-remove-‘jackOptions-…-’-from-your-build-gradle-file-and-add" class="headerlink" title="3.Warning:The Jack toolchain is deprecated. To enable support for Java 8 language features, remove ‘jackOptions { … }’ from your build.gradle file, and add"></a>3.Warning:The Jack toolchain is deprecated. To enable support for Java 8 language features, remove ‘jackOptions { … }’ from your build.gradle file, and add</h3><h5 id="问题原因-AndroidStudio2-4默认工具链通过执行字节码转换，称为实现了新的语言特性desugar，在输出-javac编译器。Jack不再需要"><a href="#问题原因-AndroidStudio2-4默认工具链通过执行字节码转换，称为实现了新的语言特性desugar，在输出-javac编译器。Jack不再需要" class="headerlink" title="问题原因:AndroidStudio2.4默认工具链通过执行字节码转换，称为实现了新的语言特性desugar，在输出 javac编译器。Jack不再需要."></a>问题原因:AndroidStudio2.4默认工具链通过执行字节码转换，称为实现了新的语言特性desugar，在输出 javac编译器。Jack不再需要.</h5><p>所以只要把jackOptions的配置去掉即可</p><p>另外现在默认支持lambda 而不需要在配置retroLambda<br>官网说明<a href="https://developer.android.google.cn/studio/preview/features/java8-support.html?utm_source=android-studio" target="_blank" rel="noopener">点击</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要说升级Android Studio2.4的一些问题及解决方案&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Android/"/>
    
      <category term="Android Studio" scheme="https://www.jianshu.com/u/3e759a2c717f/tags/Android-Studio/"/>
    
  </entry>
  
</feed>
